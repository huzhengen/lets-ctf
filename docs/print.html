<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>lets move ctf</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">lets move ctf</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="课程目标与概述"><a class="header" href="#课程目标与概述">课程目标与概述</a></h1>
<h3 id="课程目标"><a class="header" href="#课程目标">课程目标</a></h3>
<p>欢迎参加 <strong>Move CTF 挑战课程</strong>！本课程旨在帮助你掌握 Move 编程语言在 CTF（Capture The Flag）比赛中的应用，培养分析代码和解决安全挑战的能力。通过八节课的学习，你将能够：</p>
<ul>
<li>熟练分析 Move 语言代码，识别常见漏洞和逻辑错误。</li>
<li>掌握 Move 在 CTF 中的典型题型，如整数溢出、资源管理和权限控制。</li>
<li>具备独立解决基础至中级 Move CTF 题目的能力。</li>
<li>为参加 Move 相关的 CTF 比赛做好准备，树立信心。</li>
</ul>
<p>无论你是区块链开发者、安全研究者还是 CTF 爱好者，本课程都将为你提供独特的视角，探索 Move 语言的安全特性及其在竞赛中的潜力。</p>
<h3 id="课程概述"><a class="header" href="#课程概述">课程概述</a></h3>
<ul>
<li><strong>课程结构</strong>：共八章节，从零开始进阶学习Move CTF。</li>
<li><strong>学习路径</strong>：
<ul>
<li>从 CTF 简介和基础代码审计开始，逐步深入到高级漏洞和综合挑战。</li>
<li>每节课聚焦一个主题，配备一道 CTF 题目，循序渐进提升难度。</li>
</ul>
</li>
<li><strong>前提假设</strong>：你已通过基础 Move 语言学习（ <a href="https://github.com/move-cn/letsmove">HOH社区Move共学</a>），熟悉基本语法、模块和资源概念。</li>
<li><strong>预期成果</strong>：完成课程后，你将能独立分析 Move 智能合约代码，解决 CTF 挑战，并具备参加真实比赛的基本策略。</li>
</ul>
<p>本课程结合理论与实践，鼓励动手操作和互动讨论。准备好迎接挑战了吗？让我们一起开启 Move CTF 的学习之旅！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预备知识与工具安装"><a class="header" href="#预备知识与工具安装">预备知识与工具安装</a></h1>
<h2 id="预备知识"><a class="header" href="#预备知识">预备知识</a></h2>
<p>为了顺利完成本课程，你需要具备以下基础知识：</p>
<ul>
<li><strong>Move 语言基础</strong>：
<ul>
<li>熟悉变量声明、基本数据类型（u8、u64、address 等）和控制流（if、while）。</li>
<li>理解模块（module）和资源（struct）的概念。</li>
<li>能够编写和运行简单的 Move 程序（如 Hello World）。</li>
<li>推荐资源：<a href="https://github.com/move-cn/letsmove">HOH社区Move共学</a> 或 <a href="https://move.sui-book.com/index.html">Sui Move Book</a>。</li>
</ul>
</li>
<li><strong>区块链基础</strong>：
<ul>
<li>了解智能合约的基本概念（如存储、交易）。</li>
<li>对 Sui 区块链平台有初步认识。</li>
</ul>
</li>
<li><strong>CTF 基础</strong>（可选）：
<ul>
<li>知道 CTF 比赛的基本形式将有助于更快上手。</li>
</ul>
</li>
</ul>
<p>如果以上知识点有欠缺，建议先完成基础学习再加入课程。本课程将直接聚焦 Move 在 CTF 中的应用，跳过语言基础教学。</p>
<h2 id="工具安装"><a class="header" href="#工具安装">工具安装</a></h2>
<p>以下是你需要安装的工具，确保在第一节课前配置好开发环境：</p>
<ol>
<li>
<p><strong>Sui CLI</strong>：</p>
<ul>
<li>用于编译、运行和调试 Move 代码。</li>
<li>安装步骤：
<ul>
<li>Sui：参考 <a href="https://docs.sui.io/build/cli-client">Sui CLI 安装指南</a>。</li>
</ul>
</li>
<li>验证：运行 <code>sui -V</code> 检查安装成功。</li>
</ul>
</li>
<li>
<p><strong>VS Code + Move 插件</strong>：</p>
<ul>
<li>
<p>提供代码高亮和语法检查。</p>
</li>
<li>
<p>安装步骤：</p>
<ol>
<li>下载 <a href="https://code.visualstudio.com/">VS Code</a>。</li>
<li>在扩展市场搜索 <code>Move</code> 或 <code>Sui Move</code>，安装相关插件。</li>
</ol>
<p><img src="ctfbook/preface/./prerequisites.assets/image-20250325171129301.png" alt="image-20250325171039560" /></p>
<p><code>Move</code> 和 <code>Move syntax</code> 插件为提供代码高亮和语法检查，<code>Move Formatter Developer Preview</code>插件提供代码格式化。</p>
</li>
</ul>
</li>
</ol>
<h3 id="环境验证"><a class="header" href="#环境验证">环境验证</a></h3>
<ul>
<li>运行以下命令测试环境：
<pre><code class="language-bash">sui move new &lt;path-to-move-project&gt; &amp;&amp; cd &lt;path-to-move-project&gt; &amp;&amp; sui move build
</code></pre>
</li>
<li>如果编译成功，说明环境配置正确。</li>
</ul>
<p>准备好这些工具后，你就可以无缝进入课程实践环节。遇到安装问题？请提前联系课程团队或查阅相关文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第1节ctf简介与move应用"><a class="header" href="#第1节ctf简介与move应用">第1节：CTF简介与Move应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ctf比赛类型与move应用场景"><a class="header" href="#ctf比赛类型与move应用场景">CTF比赛类型与Move应用场景</a></h2>
<p>欢迎来到 <strong>Move CTF 挑战课程</strong> 的第一节！本节将带你走进 CTF（Capture The Flag，夺旗赛）的世界，了解其主要比赛类型，并探索 Move 编程语言在 Sui 区块链上的 CTF 应用场景。通过理论与实践结合，你将迈出学习 Move CTF 的第一步。</p>
<h3 id="什么是ctf"><a class="header" href="#什么是ctf">什么是CTF？</a></h3>
<p>CTF 是一种网络安全竞赛形式，参与者通过解决技术挑战获取隐藏的 “flag”（通常是一串特定格式的字符串，如 <code>CTF{xxx}</code>），以证明他们的技能。CTF 起源于 1996 年的 DEFCON 安全大会，现已成为全球安全爱好者的热门活动。比赛类型主要分为以下两种：</p>
<h4 id="1-jeopardy模式"><a class="header" href="#1-jeopardy模式">1. Jeopardy模式</a></h4>
<ul>
<li><strong>特点</strong>：解题模式，参与者面对一系列独立题目，涵盖密码学、逆向工程、Web 安全、区块链等类别。</li>
<li><strong>流程</strong>：
<ul>
<li>题目提供线索（如代码片段、文件或服务器地址）。</li>
<li>选手分析问题，找到 flag 并提交。</li>
<li>根据解题数量和速度计分。</li>
</ul>
</li>
<li><strong>适合人群</strong>：初学者和个人选手，因其灵活性和低门槛广受欢迎。</li>
<li><strong>Move相关示例</strong>：分析一段 Sui 链上的 Move 智能合约代码，找出隐藏的 flag 或利用漏洞提取数据。</li>
<li><strong>真实案例</strong>：
<ul>
<li>在 <a href="https://ctftime.org/">CTFtime</a> 上，<a href="https://www.hackthebox.com/events/cyber-apocalypse-2024">HackTheBox Cyber Apocalypse CTF 2024 Blockchain Challenges</a> 包含区块链题目，要求选手审计智能合约。</li>
<li>Sui 社区在 2024 年推出了 <a href="https://movectf2024.movebit.xyz/">MoveCTF 2024</a>，其中包括基于 Move 的解题挑战。</li>
</ul>
</li>
<li><strong>现状</strong>：当前 Move CTF（如 justCTF、MoveCTF）主要采用 Jeopardy 模式，题目以代码审计和逻辑分析为主。</li>
</ul>
<h4 id="2-attack-defense模式"><a class="header" href="#2-attack-defense模式">2. Attack-Defense模式</a></h4>
<ul>
<li><strong>特点</strong>：攻防对抗模式，团队在虚拟环境中同时攻击对手服务并防御自身系统。</li>
<li><strong>流程</strong>：
<ul>
<li>每个团队维护一个包含漏洞的服务。</li>
<li>攻击对手以获取 flag，同时修补自身漏洞。</li>
<li>综合得分决定排名。</li>
</ul>
</li>
<li><strong>适合人群</strong>：进阶选手和团队，因其更接近真实网络攻防场景。</li>
<li><strong>Move相关示例</strong>：模拟 Sui 区块链网络，攻击对手的 Move 合约（如利用未授权访问漏洞窃取资源），同时保护自己的合约免受攻击。</li>
<li><strong>现状</strong>：目前 Move CTF 未见公开的攻防模式案例，更多聚焦于解题形式的挑战。</li>
</ul>
<h4 id="ctf的吸引力"><a class="header" href="#ctf的吸引力">CTF的吸引力</a></h4>
<ul>
<li><strong>技能提升</strong>：涵盖编程、逆向、安全分析等多领域。</li>
<li><strong>实战性</strong>：模拟真实安全场景，如区块链漏洞利用。</li>
<li><strong>趣味性</strong>：解题过程如同解谜，充满成就感。</li>
</ul>
<h3 id="move-在-ctf-中的应用"><a class="header" href="#move-在-ctf-中的应用">Move 在 CTF 中的应用</a></h3>
<p>Move 是由 Facebook（现 Meta）为 Diem 区块链设计的一种编程语言，后被 Sui 公链采用并优化。它以资源导向和类型安全著称，灵感来源于 Rust。在 Sui 生态中，Move 用于编写智能合约和去中心化应用（DApp）。以下是 Move 在 CTF 中的主要应用场景：</p>
<h4 id="1-智能合约漏洞挖掘"><a class="header" href="#1-智能合约漏洞挖掘">1. 智能合约漏洞挖掘</a></h4>
<ul>
<li><strong>背景</strong>：Sui 链上的 Move 合约是 CTF 题目的常见素材，选手需分析代码，寻找漏洞。</li>
<li><strong>常见考点</strong>：
<ul>
<li><strong>整数溢出/下溢</strong>：Move 未内置溢出检查，可能导致非法操作。例如，代币转移逻辑可能因溢出被绕过。</li>
<li><strong>逻辑错误</strong>：如条件判断失误，导致意外行为。</li>
</ul>
</li>
<li><strong>示例</strong>：假设一个 Move 代币合约未检查整数加法的溢出，选手可通过构造大额输入转移超出余额的代币，flag 可能隐藏在交易事件中。</li>
<li><strong>Move特点</strong>：Move 的类型系统减少了某些传统漏洞（如重入攻击），但仍需关注逻辑和边界问题。</li>
</ul>
<h4 id="2-资源管理挑战"><a class="header" href="#2-资源管理挑战">2. 资源管理挑战</a></h4>
<ul>
<li><strong>Move特性</strong>：Move 的资源（struct）具有线性类型特性，不可随意复制或丢弃，必须显式转移或销毁。这是 Sui 链上对象（Object）管理的核心机制。</li>
<li><strong>CTF应用</strong>：
<ul>
<li>题目可能涉及资源管理不当（如未销毁资源）导致的漏洞。</li>
<li>或通过资源转移逻辑的错误绕过限制。</li>
</ul>
</li>
<li><strong>示例</strong>：设想一个 Move 合约中，开发者忘记销毁旧资源，导致资源被重复使用，选手可利用此漏洞执行双重花费。</li>
</ul>
<h4 id="3-代码逻辑逆向"><a class="header" href="#3-代码逻辑逆向">3. 代码逻辑逆向</a></h4>
<ul>
<li><strong>背景</strong>：CTF 常要求选手理解代码意图，寻找隐藏信息。</li>
<li><strong>Move场景</strong>：
<ul>
<li>flag 可能藏在注释、变量名或 Sui 链上的事件输出中。</li>
<li>或通过复杂逻辑（如循环、条件）计算得出。</li>
</ul>
</li>
<li><strong>真实案例</strong>：在 justCTF 2024 Teaser 的“The Otter Scrolls”题目（<a href="https://2024.justctf.team/challenges/11">justCTF 2024</a>）中，选手需分析 Sui Move 合约 <code>Spellbook</code>，调用 <code>cast_spell</code> 函数并传入参数 <code>vector[1, 0, 3, 3, 3]</code>，触发 flag 输出。</li>
<li><strong>总结</strong>：Move 的资源导向和类型安全特性为 CTF 提供了独特的技术挑战，目前通过 Jeopardy 模式吸引爱好者参与并提升 Sui 生态的安全意识。</li>
</ul>
<h3 id="学习目标"><a class="header" href="#学习目标">学习目标</a></h3>
<p>通过本节课，你将：</p>
<ul>
<li>理解 CTF 比赛的基本形式（Jeopardy 和 Attack-Defense）。</li>
<li>认识 Move 在 Sui 链 CTF 中的应用场景。</li>
<li>通过实践，初步体验 Move 代码分析，迈出 CTF 第一步。</li>
</ul>
<p>准备好了吗？接下来，我们将通过一个简单实践，体验 Move CTF！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践签到挑战"><a class="header" href="#实践签到挑战">实践：签到挑战</a></h1>
<h2 id="题目描述"><a class="header" href="#题目描述">题目描述</a></h2>
<p>在本实践环节，你将分析一个 Sui Move 签到合约，通过计算哈希值调用函数，获取隐藏的 flag。flag 是一个格式为 <code>CTF{xxx}</code> 的字符串，将在正确输入时通过事件输出。目标是体验 Move 代码分析和基本 CTF 解题流程。</p>
<h2 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h2>
<p>以下是待分析的 Move 合约：</p>
<p>github: <a href="https://github.com/hoh-zone/lets-ctf/tree/main/src/ctfbook/chapter_1/challenge/chapter_1">chapter_1</a></p>
<pre><code class="language-move">module chapter_1::check_in {
    use std::string::{Self, String};
    use std::bcs;
    use std::hash::sha3_256;
    use sui::event;

    //testnet
    //PackageID:0x335297860a807291254b20f8a0dea30d72d5e17d2e6f8058e42d5b9c72f0f0ef
    public struct FlagEvent has copy, drop {
        sender: address,
        flag: String,
        success: bool
    }

    public entry fun get_flag(
        flag: vector&lt;u8&gt;,
        github_id: String,
        ctx: &amp;mut TxContext
    ) {
        let mut bcs_input = bcs::to_bytes(&amp;string::utf8(b"LetsMoveCTF"));
        vector::append&lt;u8&gt;(&amp;mut bcs_input, *github_id.as_bytes());
        let expected_hash = sha3_256(bcs_input);

        if (flag == expected_hash) {
            event::emit(FlagEvent {
                sender: tx_context::sender(ctx),
                flag: string::utf8(b"CTF{WelcomeToMoveCTF}"),
                success: true
            });
        } else {
            event::emit(FlagEvent {
                sender: tx_context::sender(ctx),
                flag: string::utf8(b"Try again!"),
                success: false
            });
        }
    }
}
</code></pre>
<h2 id="任务目标"><a class="header" href="#任务目标">任务目标</a></h2>
<p>阅读代码，理解哈希验证逻辑。</p>
<p>计算正确的 flag 输入并运行代码，获取 flag。</p>
<h2 id="解题思路"><a class="header" href="#解题思路">解题思路</a></h2>
<p>1、找到如何获取flag的代码块：</p>
<pre><code class="language-move">##其中 `flag == expected_hash` 为获取flag的条件
if (flag == expected_hash) {
    event::emit(FlagEvent {
        sender: tx_context::sender(ctx),
        flag: string(b"CTF{WelcomeToMoveCTF}"),
        success: true
    });
} else {
    event::emit(FlagEvent {
        sender: tx_context::sender(ctx),
        flag: string(b"Try again!"),
        success: false
    });
}
</code></pre>
<p>2、如何满足 <code>flag == expected_hash</code> 条件？</p>
<pre><code class="language-move">let mut bcs_input = bcs::to_bytes(&amp;string(b"LetsMoveCTF"));
vector::append&lt;u8&gt;(&amp;mut bcs_input, *github_id.as_bytes());
let expected_hash = sha3_256(bcs_input);
</code></pre>
<p>代码块中 expected_hash 为 <code>LetsMoveCTF</code> + 用户输入的<code>github_id</code> 转换为bytes然后sha3_256 进行编码，所以flag传入也需要是expected_hash的这个结果。</p>
<p>3、进行解题</p>
<p>这里采用的是合约的方式进行解题。</p>
<p>github: <a href="https://github.com/hoh-zone/lets-ctf/tree/main/src/ctfbook/chapter_1/challenge/solve_chapter_1">solve_chapter_1</a>
首先创建合约:</p>
<p><code>sui move new solve_chapter_1 &amp;&amp; cd solve_chapter_1</code></p>
<p>修改 <code>Move.toml</code> 文件导入题目合约,如果是本地与题目同目录则添加 <code>local</code> 方式:</p>
<pre><code>[package]
name = "solve_chapter_1"
edition = "2024.beta" # edition = "legacy" to use legacy (pre-2024) Move
# license = ""           # e.g., "MIT", "GPL", "Apache 2.0"
# authors = ["..."]      # e.g., ["Joe Smith (joesmith@noemail.com)", "John Snow (johnsnow@noemail.com)"]

[dependencies]
chapter_1 = { local = "../chapter_1" }

# For remote import, use the `{ git = "...", subdir = "...", rev = "..." }`.
# Revision can be a branch, a tag, and a commit hash.
# MyRemotePackage = { git = "https://some.remote/host.git", subdir = "remote/path", rev = "main" }

# For local dependencies use `local = path`. Path is relative to the package root
# Local = { local = "../path/to" }

# To resolve a version conflict and force a specific version for dependency
# override use `override = true`
# Override = { local = "../conflicting/version", override = true }

[addresses]
solve_chapter_1 = "0x0"

# Named addresses will be accessible in Move as `@name`. They're also exported:
# for example, `std = "0x1"` is exported by the Standard Library.
# alice = "0xA11CE"

[dev-dependencies]
# The dev-dependencies section allows overriding dependencies for `--test` and
# `--dev` modes. You can introduce test-only dependencies here.
# Local = { local = "../path/to/dev-build" }

[dev-addresses]
# The dev-addresses section allows overwriting named addresses for the `--test`
# and `--dev` modes.
# alice = "0xB0B"

</code></pre>
<p>然后编写解题合约 <code>solve_chapter_1.move</code>:</p>
<pre><code class="language-move">module solve_chapter_1::solve{
    use chapter_1::check_in::get_flag;
    use std::string;
    use std::bcs;
    use std::hash::sha3_256;

    //testnet
    //PackageID: 0xef6b4139ec1b0fda23e06c4a30c9e91150b72c38530e4517152e591001c5c433 
    public entry fun solve_get_flag(ctx: &amp;mut TxContext){
        let github_id = string::utf8(b"hoh-zone");
        let mut bcs_input = bcs::to_bytes(&amp;string::utf8(b"LetsMoveCTF"));
        vector::append&lt;u8&gt;(&amp;mut bcs_input, *github_id.as_bytes());
        let flag_hash = sha3_256(bcs_input);
        get_flag(flag_hash, github_id, ctx);  
    }
}
</code></pre>
<p>发布合约:</p>
<p><code>sui client publish</code></p>
<p>发布成功后调用合约：</p>
<pre><code class="language-bash">sui client call --package 0xef6b4139ec1b0fda23e06c4a30c9e91150b72c38530e4517152e591001c5c433 --module solve --function solve_get_flag
</code></pre>
<p>最终结果可以看到终端输出的Events内成功获取flag：</p>
<pre><code class="language-bash">╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Block Events                                                                              │
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                                  │
│  │ EventID: EjQiJnPZRqen1TSSkNiUaRaEQYSmhshJYHctn3uUt1V5:0                                            │
│  │ PackageID: 0xef6b4139ec1b0fda23e06c4a30c9e91150b72c38530e4517152e591001c5c433                      │
│  │ Transaction Module: solve                                                                          │
│  │ Sender: 0x90abb670800b4015229d30f5d010faef0c347e1d9650c9acebe2c012be7eb724                         │
│  │ EventType: 0x335297860a807291254b20f8a0dea30d72d5e17d2e6f8058e42d5b9c72f0f0ef::check_in::FlagEvent │
│  │ ParsedJSON:                                                                                        │
│  │   ┌─────────┬────────────────────────────────────────────────────────────────────┐                 │
│  │   │ flag    │ CTF{WelcomeToMoveCTF}                                              │                 │
│  │   ├─────────┼────────────────────────────────────────────────────────────────────┤                 │
│  │   │ sender  │ 0x90abb670800b4015229d30f5d010faef0c347e1d9650c9acebe2c012be7eb724 │                 │
│  │   ├─────────┼────────────────────────────────────────────────────────────────────┤                 │
│  │   │ success │ true                                                               │                 │
│  │   └─────────┴────────────────────────────────────────────────────────────────────┘                 │
│  └──                                                                                                  │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第2节基础代码审计"><a class="header" href="#第2节基础代码审计">第2节：基础代码审计</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅读move代码与常见问题"><a class="header" href="#阅读move代码与常见问题">阅读Move代码与常见问题</a></h1>
<h2 id="阅读-move-代码与常见问题"><a class="header" href="#阅读-move-代码与常见问题">阅读 Move 代码与常见问题</a></h2>
<p>欢迎来到 <strong>Move CTF 挑战课程</strong> 的第二节！在第一节中，你通过一个签到挑战初步体验了 Move 代码的分析和解题流程。现在，我们将迈出审计的第一步，深入学习如何阅读 Move 代码并识别常见问题。本节将通过详细的理论讲解和实践环节，帮助你掌握基础审计技能，为后续更复杂的漏洞分析打下坚实基础。</p>
<h4 id="1-模块与函数"><a class="header" href="#1-模块与函数">1. 模块与函数</a></h4>
<ul>
<li><strong>模块（Module）</strong>：
<ul>
<li>Move 的代码组织单元，类似于传统语言中的合约或类。</li>
<li>格式：<code>module &lt;address&gt;::&lt;name&gt;</code>，其中 <code>&lt;address&gt;</code> 是部署地址（如 <code>0x1</code>），<code>&lt;name&gt;</code> 是模块名。</li>
<li>包含结构体、常量和函数，定义合约的逻辑。</li>
<li>示例：
<pre><code>module chapter_2_test::counter {

    public struct Counter has key {
        id: UID,
        count: u64,
    }

    fun init(ctx: &amp;mut TxContext){
        transfer::share_object(Counter { id:object::new(ctx), count: 0 });
        
    }

    public entry fun increment(counter: &amp;mut Counter) {
        counter.count = counter.count + 1;
    }
}
</code></pre>
</li>
</ul>
</li>
<li><strong>函数类型</strong>：
<ul>
<li><code>public entry fun</code>：外部可调用的入口函数，通常是 CTF 题目中的交互点，接受 <code>&amp;mut TxContext</code> 参数以获取交易上下文。</li>
<li><code>public fun</code>：公开函数，可被其他模块调用，但不直接作为交易入口。</li>
<li><code>fun</code>：私有函数，仅模块内部使用。</li>
<li>示例：
<pre><code>public entry fun set_value(value: u64, tx: &amp;mut TxContext) { 
    /* 交易入口 */ 
}
fun internal_add(a: u64, b: u64): u64 { a + b } // 内部辅助函数
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2-资源与所有权"><a class="header" href="#2-资源与所有权">2. 资源与所有权</a></h4>
<ul>
<li><strong>资源（Resource）</strong>：
<ul>
<li>Move 的核心特性，使用 <code>struct</code> 定义，带有能力（<code>has</code> 声明，如 <code>key</code>、<code>store</code>）。</li>
<li>线性类型：资源不可复制（<code>copy</code>）或丢弃（<code>drop</code>），必须显式转移或销毁。</li>
<li>示例：
<pre><code>public struct Coin has key {
    id: UID,
    value: u64  
}
</code></pre>
</li>
</ul>
</li>
<li><strong>所有权管理</strong>：
<ul>
<li>创建资源后，可通过 <code>transfer::transfer</code>（转移给地址）或 <code>transfer::share_object</code>（共享对象）等处理。</li>
<li>示例：
<pre><code>public entry fun create(ctx: &amp;mut TxContext){
    let coin = Coin { id: object::new(ctx), value: 100 };
    transfer::transfer(coin, tx_context::sender(ctx));
}
</code></pre>
</li>
<li>未处理资源会导致编译错误，确保所有权清晰。</li>
</ul>
</li>
<li><strong>Sui 特有机制</strong>：
<ul>
<li><strong>对象（Object）</strong>：通过 <code>UID</code>（唯一标识符）管理，Sui 的基本数据单元。</li>
<li><strong>共享对象</strong>：通过 <code>transfer::share_object</code> 创建，允许多人操作，常用于 CTF 的共享状态。</li>
</ul>
</li>
</ul>
<h4 id="3-事件与输出"><a class="header" href="#3-事件与输出">3. 事件与输出</a></h4>
<ul>
<li><strong>事件（Event）</strong>：
<ul>
<li>通过 <code>event::emit</code> 输出日志，用于记录状态变化或 CTF 中的 flag 输出。</li>
<li>需定义事件结构体，具备 <code>copy</code> 和 <code>drop</code> 能力。</li>
<li>示例：
<pre><code>public struct FlagEvent has copy, drop {
    sender: address,
    flag: vector&lt;u8&gt;
}

public entry fun get_flag(ctx: &amp;mut TxContext){
    event::emit(FlagEvent { sender: tx_context::sender(ctx), flag: b"CTF{example}" });
}
</code></pre>
</li>
<li>CTF 中，事件常是获取 flag 的关键途径。</li>
</ul>
</li>
</ul>
<h4 id="4-变量与类型"><a class="header" href="#4-变量与类型">4. 变量与类型</a></h4>
<ul>
<li><strong>基本类型</strong>：
<ul>
<li><code>u8</code>、<code>u64</code>、<code>u128</code>：无符号整数。</li>
<li><code>bool</code>：布尔值。</li>
<li><code>address</code>：账户地址。</li>
<li><code>vector&lt;T&gt;</code>：动态数组。</li>
</ul>
</li>
<li><strong>引用</strong>：
<ul>
<li><code>&amp;T</code>：不可变引用，用于读取。</li>
<li><code>&amp;mut T</code>：可变引用，用于修改。</li>
<li>示例：
<pre><code>public entry fun increment(counter: &amp;mut Counter) {
    counter.count = counter.count + 1;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="常见问题与漏洞类型"><a class="header" href="#常见问题与漏洞类型">常见问题与漏洞类型</a></h3>
<h4 id="1-未验证的输入"><a class="header" href="#1-未验证的输入">1. 未验证的输入</a></h4>
<ul>
<li><strong>影响</strong>：
<ul>
<li>若 <code>limit</code> 被设置为异常值（如 <code>2^64 - 1</code>），后续逻辑可能失效。</li>
<li>在 CTF 中，可能通过异常输入绕过限制或提取 flag。</li>
</ul>
</li>
</ul>
<h4 id="2-逻辑错误"><a class="header" href="#2-逻辑错误">2. 逻辑错误</a></h4>
<ul>
<li>
<p><strong>问题</strong>：条件判断、状态更新或流程控制错误，导致与设计意图不符的结果。</p>
</li>
<li>
<p><strong>详细说明</strong>：</p>
<ul>
<li>Move 依赖开发者正确实现逻辑，无内置保护机制。</li>
<li>常见于条件遗漏、顺序错误或判断反转。</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code>public struct AccessControl has key {
    id: UID,
    is_allowed: bool,
    threshold: u64
}

public entry fun check_access(access: &amp;mut AccessControl, score: u64) {
    if (score &gt; 50) { // 应为 &gt;= 50，但是设置为 &gt;50
        access.is_allowed = true;
    }
}
</code></pre>
</li>
<li>
<p>边界值 score = 50 被意外排除.</p>
</li>
<li>
<p><strong>更复杂示例</strong>：</p>
<pre><code>public entry fun update_state(state: &amp;mut AccessControl, value: u64) {
  if (value &lt; state.threshold) {
      state.is_allowed = false; // 可能应为 true
  }
}
</code></pre>
<ul>
<li>若意图是“低于阈值激活”，条件与赋值不符。</li>
</ul>
</li>
<li>
<p><strong>影响</strong>：</p>
<ul>
<li>可能允许未授权操作或阻止合法行为。</li>
</ul>
</li>
</ul>
<h4 id="3-权限控制不足"><a class="header" href="#3-权限控制不足">3. 权限控制不足</a></h4>
<ul>
<li><strong>问题</strong>：函数未限制调用者身份，允许任何人执行敏感操作。</li>
<li><strong>详细说明</strong>：
<ul>
<li>Move 的 public entry fun 默认对所有地址开放，需手动验证 tx_context::sender.</li>
<li>Sui 的共享对象尤其需注意权限。</li>
</ul>
</li>
<li><strong>示例</strong>：
<pre><code>public entry fun reset_counter(counter: &amp;mut Counter) { // 未验证调用者
  counter.count = 0; 
}
</code></pre>
<ul>
<li>任何人都可重置计数器。</li>
</ul>
</li>
<li><strong>更实际示例</strong>：
<pre><code>public struct SuiPool has key {
    id: UID,
    suiBalance: Balance&lt;0x2::sui::SUI&gt;,
}

public entry fun withdraw_commision(
    suipool: &amp;mut SuiPool,
    amount: u64,
    to: address,
    ctx: &amp;mut TxContext,
) {
    assert!(suipool.suiBalance.value() &gt; amount, 1);
    let coin_balance = suipool.suiBalance.split(amount);
    let coin = from_balance(coin_balance, ctx);
    public_transfer(coin, to);
}
</code></pre>
<ul>
<li>非管理者可提取余额。</li>
</ul>
</li>
<li><strong>影响</strong>：
<ul>
<li>未授权用户可能破坏合约状态或窃取资源。</li>
</ul>
</li>
</ul>
<h4 id="4-整数溢出下溢"><a class="header" href="#4-整数溢出下溢">4. 整数溢出/下溢</a></h4>
<ul>
<li><strong>问题</strong>：在 Sui 中，Move 的整数运算（如 u64 的加法、减法）默认启用溢出检查，溢出或下溢会导致交易失败.</li>
<li><strong>示例</strong>：
<pre><code>module counter::counter{
    use sui::event;

    public struct Counter has key {
        id: UID,
        count: u64,
    }

    public struct CounterEmit has copy, drop{
        count: u64,
    }

    fun init(ctx: &amp;mut TxContext){
        transfer::share_object(Counter { id:object::new(ctx), count: 0 });
    }

    public entry fun add(counter: &amp;mut Counter,amount: u64){
        counter.count = counter.count + amount;
        event::emit(CounterEmit { count: counter.count })
    }

    public entry fun reduce(counter: &amp;mut Counter,amount: u64){
        counter.count = counter.count - amount;
        event::emit(CounterEmit { count: counter.count })
    }
}
</code></pre>
</li>
<li><strong>影响</strong>：
<ul>
<li>若 counter + amount &gt; 2^64 - 1 或 counter - amount &lt; 0 会抛出 MovePrimitiveRuntimeError，交易失败，无法继续执行。</li>
</ul>
</li>
</ul>
<h4 id="5-资源管理不当"><a class="header" href="#5-资源管理不当">5. 资源管理不当</a></h4>
<ul>
<li><strong>问题</strong>：资源未正确转移或销毁，导致编译错误。</li>
<li><strong>示例</strong>：
<pre><code>public entry fun create_coin(ctx: &amp;mut TxContext) {
  let coin = Coin { id: object::new(ctx), value: 100 };
}
</code></pre>
</li>
<li><strong>影响</strong>：
<ul>
<li>编译错误。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践识别与修复简单漏洞"><a class="header" href="#实践识别与修复简单漏洞">实践：识别与修复简单漏洞</a></h1>
<h2 id="题目描述-1"><a class="header" href="#题目描述-1">题目描述</a></h2>
<p>在本实践环节，你将审计一个简单的 Sui Move 合约 chapter_2::simple_challenge，目标是识别其中的漏洞并提出修复建议。合约实现了一个简单的“计数挑战”：用户可以通过提交计数（increment_count）来增加计数器，达到目标值后领取奖励（claim_reward）。奖励是共享的，任何人都可以领取。然而，合约存在一些隐藏漏洞，其中一个可能导致运行时报错，你需要找到这些漏洞，分析其影响，并提出修复建议。</p>
<h2 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h2>
<p>以下是 chapter_2::simple_challenge 模块的代码：</p>
<p>move</p>
<pre><code class="language-text">module chapter_2::simple_challenge {
    use sui::object::{Self, UID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};
    use sui::event;

    public struct Challenge has key {
        id: UID,
        owner: address,
        count: u64,
        target_count: u64,
        reward: u64,
        total_rewards_claimed: u64,
        total_attempts: u64,
    }

    public struct RewardEvent has copy, drop {
        reward: u64,
    }

    fun init(ctx: &amp;mut TxContext) {
        let challenge = Challenge {
            id: object::new(ctx),
            owner: tx_context::sender(ctx),
            count: 0,
            target_count: 10,
            reward: 1000,
            total_rewards_claimed: 0,
            total_attempts: 0,
        };
        transfer::share_object(challenge);
    }

    public entry fun increment_count(challenge: &amp;mut Challenge) {
        challenge.total_attempts = challenge.total_attempts + 1;
        challenge.count = challenge.count + 1;
    }

    public entry fun claim_reward(challenge: &amp;mut Challenge, ctx: &amp;mut TxContext) {
        if (challenge.count &gt;= challenge.target_count) {
            challenge.total_rewards_claimed = challenge.total_rewards_claimed + challenge.reward;
            event::emit(RewardEvent { reward: challenge.reward });
            challenge.count = 0;
        };
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第3章泛型类型安全"><a class="header" href="#第3章泛型类型安全">第3章：泛型类型安全</a></h1>
<h2 id="引言"><a class="header" href="#引言">引言</a></h2>
<p>在区块链智能合约开发中，安全性是核心关注点。Sui Move 作为一种专为高性能区块链设计的语言，通过其强大的类型系统为开发者提供了安全保障。然而，某些特性如果使用不当，可能引入严重漏洞。本章将聚焦 <strong>Sui Move 的泛型（Generics）</strong>，深入探讨其在智能合约中的应用以及未检查泛型类型带来的安全风险。</p>
<hr />
<h2 id="1-sui-move-中的泛型"><a class="header" href="#1-sui-move-中的泛型">1. Sui Move 中的泛型</a></h2>
<h3 id="11-什么是泛型"><a class="header" href="#11-什么是泛型">1.1 什么是泛型？</a></h3>
<p>泛型是编程语言中的一种机制，允许开发者编写可以处理多种类型的通用代码，从而提高代码的灵活性和复用性。在 Sui Move 中，泛型通过类型参数（如 <code>&lt;T&gt;</code>）实现，类型参数可以在结构体、函数或模块定义中使用，指定在运行时替换的具体类型，类型参数通过尖括号 <code>&lt;T&gt;</code> 定义。</p>
<p>例如，在合约中，<code>VoteToken</code> 结构体使用泛型 <code>&lt;T&gt;</code> 表示投票凭证的类型：</p>
<pre><code>public struct VoteToken&lt;phantom T&gt; has key, store {
    id: UID,
    amount: u64,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 是类型参数，可以代表任何类型（如 <code>OfficialToken</code> 或攻击者定义的 <code>FakeToken</code>）。</li>
<li><code>phantom</code> 关键字表示 <code>&lt;T&gt;</code> 仅用于类型标记，不影响 <code>VoteToken</code> 的存储结构（即不会在链上存储 <code>&lt;T&gt;</code> 的实例）。</li>
<li><code>has key, store</code> 表明 <code>VoteToken</code> 是一个链上对象，可以存储和转移。</li>
</ul>
<p>泛型的核心优势是允许开发者编写通用的逻辑，而无需为每种类型重复实现代码。</p>
<h3 id="12-泛型的语法与能力"><a class="header" href="#12-泛型的语法与能力">1.2 泛型的语法与能力</a></h3>
<p>在 Sui Move 中，泛型的使用受到类型能力的约束：</p>
<ul>
<li>
<p><strong>结构体泛型</strong>：如 <code>VoteToken&lt;phantom T&gt;</code>，类型参数 <code>&lt;T&gt;</code> 通常需要满足特定能力（如 <code>drop</code> 或 <code>store</code>）。例如，<code>phantom</code> 参数通常要求 <code>drop</code> 能力。</p>
</li>
<li>
<p><strong>函数泛型</strong>：函数可以声明泛型参数，限制调用时传入的类型。例如：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
  let sender = tx_context::sender(ctx);
  let token = VoteToken&lt;T&gt; {
      id: object::new(ctx),
      amount: 100,
  };
  public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 允许函数为任意类型创建 <code>VoteToken</code>。</li>
<li>调用者可以在调用时指定具体类型，如 <code>register_voter&lt;0x1::Token::Token&gt;</code>。</li>
</ul>
</li>
<li>
<p><strong>多类型参数</strong>：支持多个类型参数，顺序重要。例如：</p>
<pre><code>public struct Pair&lt;T, U&gt; {
  first: T,
  second: U,
}
public fun new_pair&lt;T, U&gt;(first: T, second: U): Pair&lt;T, U&gt; {
  Pair { first, second }
}
</code></pre>
<ul>
<li><code>&lt;T, U&gt;</code> 的顺序决定类型签名，<code>Pair&lt;u8, bool&gt;</code> 和 <code>Pair&lt;bool, u8&gt;</code> 是不同类型，无法直接比较。</li>
</ul>
</li>
<li>
<p><strong>幻影类型参数</strong>：未在字段或方法中使用的类型参数，用于区分类型。例如：</p>
<pre><code>public struct Coin&lt;phantom T&gt; {
  value: u64
}

public struct USD {}
public struct EUR {}

#[test]
fun test_phantom_type() {
    let coin1: Coin&lt;USD&gt; = Coin { value: 10 };
    let coin2: Coin&lt;EUR&gt; = Coin { value: 20 };

    // Unpacking is identical because the phantom type parameter is not used.
    let Coin { value: _ } = coin1;
    let Coin { value: _ } = coin2;
}
</code></pre>
<ul>
<li><code>Coin&lt;USD&gt;</code> 和 <code>Coin&lt;EUR&gt;</code> 使用 <code>&lt;T&gt;</code> 区分不同货币，防止混淆。</li>
</ul>
</li>
<li>
<p><strong>能力约束</strong>：类型参数可通过能力约束（如 <code>T: drop</code>）限制行为。例如：</p>
<pre><code>public struct Droppable&lt;T: drop&gt; {
  value: T,
}
public struct CopyableDroppable&lt;T: copy + drop&gt; {
  value: T,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 必须具有指定能力，否则编译器报错。例如，<code>NoAbilities</code> 结构体无能力，无法用于 <code>Droppable&lt;NoAbilities&gt;</code>.</li>
</ul>
</li>
</ul>
<h3 id="13-泛型的应用场景"><a class="header" href="#13-泛型的应用场景">1.3 泛型的应用场景</a></h3>
<p>在 Sui Move 智能合约中，泛型广泛应用于：</p>
<ul>
<li><strong>资源标识</strong>：如 <code>VoteToken&lt;T&gt;</code>，通过 <code>&lt;T&gt;</code> 区分不同类型的凭证（如治理代币、投票权）。</li>
<li><strong>模块复用</strong>：编写通用逻辑，适配多种类型。例如，<code>vote&lt;T&gt;</code> 函数处理不同类型的 <code>VoteToken</code>。</li>
<li><strong>跨模块交互</strong>：泛型支持模块与外部类型交互，增加灵活性。</li>
<li><strong>标准库</strong>：如 <code>vector&lt;T&gt;</code>（动态数组）和 <code>Option&lt;T&gt;</code>（可选值），分别存储任意类型序列和表示可能缺失的值。</li>
<li><strong>抽象实现</strong>：定义通用接口或行为，允许不同类型共享逻辑。</li>
</ul>
<p>在样例合约中，泛型用于：</p>
<ul>
<li><code>VoteToken&lt;phantom T&gt;</code>：标记投票凭证的合法性。</li>
<li><code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code>：支持不同类型凭证的分配和使用。</li>
</ul>
<p>然而，这种灵活性可能被攻击者利用，导致安全漏洞。</p>
<hr />
<h2 id="2-未检查泛型类型的安全风险"><a class="header" href="#2-未检查泛型类型的安全风险">2. 未检查泛型类型的安全风险</a></h2>
<h3 id="21-泛型漏洞的本质"><a class="header" href="#21-泛型漏洞的本质">2.1 泛型漏洞的本质</a></h3>
<p>在 Sui Move 中，泛型类型是由调用者在运行时提供的“用户输入”。如果合约未验证泛型类型 <code>&lt;T&gt;</code> 是否符合预期，攻击者可以传入任意类型，导致以下安全问题：</p>
<ul>
<li><strong>伪造凭证</strong>：攻击者创建非法类型的对象（如 <code>VoteToken&lt;FakeToken&gt;</code>）绕过权限检查。</li>
<li><strong>逻辑破坏</strong>：非预期类型导致合约状态异常，影响核心功能（如投票结果错误）。</li>
<li><strong>资源滥用</strong>：攻击者利用伪造类型创建无效资源，干扰合约运行或耗尽 Gas.</li>
</ul>
<p>在 <code>VoteChain</code> 合约中，<code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code> 函数未检查 <code>&lt;T&gt;</code> 类型，存在严重漏洞：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}

public entry fun vote&lt;T&gt;(store: &amp;mut VoteStore, token: &amp;VoteToken&lt;T&gt;, proposal_id: u64) {
    assert!(token.amount &gt; 0, 1);
    assert!(object_table::contains(&amp;store.proposals, proposal_id), 2);
    let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_id);
    proposal.votes = proposal.votes + token.amount;
}
</code></pre>
<ul>
<li><strong>漏洞</strong>：<code>register_voter&lt;T&gt;</code> 允许任何 <code>&lt;T&gt;</code> 创建 <code>VoteToken</code>，<code>vote&lt;T&gt;</code> 未验证 <code>token</code> 的类型。</li>
<li><strong>后果</strong>：攻击者可以伪造 <code>VoteToken</code> 并投票，非法影响提案结果.</li>
</ul>
<h3 id="22-漏洞案例分析"><a class="header" href="#22-漏洞案例分析">2.2 漏洞案例分析</a></h3>
<p>假设 <code>VoteChain</code> 是一个去中心化投票系统，设计意图是只有持有 <code>OfficialToken</code> 类型凭证的用户才能投票。然而，由于泛 type漏洞，攻击者可以：</p>
<ol>
<li>定义一个伪造类型 <code>FakeToken</code>:</li>
</ol>
<pre><code>module attacker::fake_token {
 public struct FakeToken has drop {}
}
</code></pre>
<ol start="2">
<li>调用 <code>register_voter&lt;attacker::fake_token::FakeToken&gt;</code> 获取 <code>VoteToken&lt;FakeToken&gt;</code>.</li>
<li>使用伪造的 <code>VoteToken&lt;FakeToken&gt;</code> 调用 <code>vote</code>，增加任意提案的票数。</li>
</ol>
<p>这种攻击在区块链 CTF 中非常常见，因为泛型类型作为“隐形输入”，容易被开发者忽视。在现实世界的治理合约或 DeFi 协议中，类似漏洞可能导致：</p>
<ul>
<li>非法用户控制投票结果。</li>
<li>资金分配错误。</li>
<li>协议治理被恶意操纵。</li>
</ul>
<h3 id="23-漏洞的影响"><a class="header" href="#23-漏洞的影响">2.3 漏洞的影响</a></h3>
<p>未检查泛型类型的漏洞可能导致：</p>
<ul>
<li><strong>完整性破坏</strong>：投票系统等依赖权限控制的合约可能被非法操作。</li>
<li><strong>经济损失</strong>：在 DeFi 或 DAO 中，伪造凭证可能导致资金被窃取或错误分配。</li>
<li><strong>拒绝服务</strong>：攻击者可能创建大量伪造对象，增加 Gas 消耗或干扰正常功能。</li>
</ul>
<p>在 <code>VoteChain</code> 的场景中，攻击者通过伪造 <code>VoteToken</code> 可以：</p>
<ul>
<li>使无效用户参与投票，破坏提案的公平性。</li>
<li>操纵提案结果，影响治理决策。</li>
<li>降低系统的可信度，损害用户信任。</li>
</ul>
<hr />
<h2 id="3-防御泛型漏洞"><a class="header" href="#3-防御泛型漏洞">3. 防御泛型漏洞</a></h2>
<h3 id="31-使用-stdtype_name-进行类型检查"><a class="header" href="#31-使用-stdtype_name-进行类型检查">3.1 使用 <code>std::type_name</code> 进行类型检查</a></h3>
<p>Sui Move 提供了 <code>std::type_name</code> 模块，用于在运行时检查类型的名称。开发者可以在合约中添加断言，确保泛型类型 <code>&lt;T&gt;</code> 符合预期：</p>
<pre><code>use std::type_name;

public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    assert!(type_name::get&lt;T&gt;() == type_name::get&lt;votechain::OfficialToken&gt;(), 3);
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>type_name::get&lt;T&gt;()</code> 返回 <code>&lt;T&gt;</code> 的完整类型名称（包括模块和结构体名称，如 <code>votechain::OfficialToken</code>）。</li>
<li>断言确保 <code>&lt;T&gt;</code> 是 <code>votechain::OfficialToken</code>，否则中止交易。</li>
<li>错误码 <code>3</code>（建议定义为常量，如 <code>const E_INVALID_TYPE: u64 = 3;</code>）便于调试。</li>
</ul>
<p>这种方法通过限制 <code>&lt;T&gt;</code> 到白名单类型，有效防止伪造凭证。</p>
<h3 id="32-设计安全合约的注意事项"><a class="header" href="#32-设计安全合约的注意事项">3.2 设计安全合约的注意事项</a></h3>
<ul>
<li><strong>最小化泛型使用</strong>：仅在必要时使用泛型，避免过度灵活性。</li>
<li><strong>显式验证</strong>：对所有泛型参数进行运行时检查。</li>
<li><strong>错误处理</strong>：定义清晰的错误码，便于调试和审计。</li>
<li><strong>测试覆盖</strong>：编写测试用例，模拟攻击者伪造类型的情景。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="了解泛型类型安全"><a class="header" href="#了解泛型类型安全">了解泛型类型安全</a></h1>
<h2 id="引言-1"><a class="header" href="#引言-1">引言</a></h2>
<p>在区块链智能合约开发中，安全性是核心关注点。Sui Move 作为一种专为高性能区块链设计的语言，通过其强大的类型系统为开发者提供了安全保障。然而，某些特性如果使用不当，可能引入严重漏洞。本章将聚焦 <strong>Sui Move 的泛型（Generics）</strong>，深入探讨其在智能合约中的应用以及未检查泛型类型带来的安全风险。</p>
<hr />
<h2 id="1-sui-move-中的泛型-1"><a class="header" href="#1-sui-move-中的泛型-1">1. Sui Move 中的泛型</a></h2>
<h3 id="11-什么是泛型-1"><a class="header" href="#11-什么是泛型-1">1.1 什么是泛型？</a></h3>
<p>泛型是编程语言中的一种机制，允许开发者编写可以处理多种类型的通用代码，从而提高代码的灵活性和复用性。在 Sui Move 中，泛型通过类型参数（如 <code>&lt;T&gt;</code>）实现，类型参数可以在结构体、函数或模块定义中使用，指定在运行时替换的具体类型，类型参数通过尖括号 <code>&lt;T&gt;</code> 定义。</p>
<p>例如，在合约中，<code>VoteToken</code> 结构体使用泛型 <code>&lt;T&gt;</code> 表示投票凭证的类型：</p>
<pre><code>public struct VoteToken&lt;phantom T&gt; has key, store {
    id: UID,
    amount: u64,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 是类型参数，可以代表任何类型（如 <code>OfficialToken</code> 或攻击者定义的 <code>FakeToken</code>）。</li>
<li><code>phantom</code> 关键字表示 <code>&lt;T&gt;</code> 仅用于类型标记，不影响 <code>VoteToken</code> 的存储结构（即不会在链上存储 <code>&lt;T&gt;</code> 的实例）。</li>
<li><code>has key, store</code> 表明 <code>VoteToken</code> 是一个链上对象，可以存储和转移。</li>
</ul>
<p>泛型的核心优势是允许开发者编写通用的逻辑，而无需为每种类型重复实现代码。</p>
<h3 id="12-泛型的语法与能力-1"><a class="header" href="#12-泛型的语法与能力-1">1.2 泛型的语法与能力</a></h3>
<p>在 Sui Move 中，泛型的使用受到类型能力的约束：</p>
<ul>
<li>
<p><strong>结构体泛型</strong>：如 <code>VoteToken&lt;phantom T&gt;</code>，类型参数 <code>&lt;T&gt;</code> 通常需要满足特定能力（如 <code>drop</code> 或 <code>store</code>）。例如，<code>phantom</code> 参数通常要求 <code>drop</code> 能力。</p>
</li>
<li>
<p><strong>函数泛型</strong>：函数可以声明泛型参数，限制调用时传入的类型。例如：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
  let sender = tx_context::sender(ctx);
  let token = VoteToken&lt;T&gt; {
      id: object::new(ctx),
      amount: 100,
  };
  public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 允许函数为任意类型创建 <code>VoteToken</code>。</li>
<li>调用者可以在调用时指定具体类型，如 <code>register_voter&lt;0x1::Token::Token&gt;</code>。</li>
</ul>
</li>
<li>
<p><strong>多类型参数</strong>：支持多个类型参数，顺序重要。例如：</p>
<pre><code>public struct Pair&lt;T, U&gt; {
  first: T,
  second: U,
}
public fun new_pair&lt;T, U&gt;(first: T, second: U): Pair&lt;T, U&gt; {
  Pair { first, second }
}
</code></pre>
<ul>
<li><code>&lt;T, U&gt;</code> 的顺序决定类型签名，<code>Pair&lt;u8, bool&gt;</code> 和 <code>Pair&lt;bool, u8&gt;</code> 是不同类型，无法直接比较。</li>
</ul>
</li>
<li>
<p><strong>幻影类型参数</strong>：未在字段或方法中使用的类型参数，用于区分类型。例如：</p>
<pre><code>public struct Coin&lt;phantom T&gt; {
  value: u64
}

public struct USD {}
public struct EUR {}

#[test]
fun test_phantom_type() {
    let coin1: Coin&lt;USD&gt; = Coin { value: 10 };
    let coin2: Coin&lt;EUR&gt; = Coin { value: 20 };

    // Unpacking is identical because the phantom type parameter is not used.
    let Coin { value: _ } = coin1;
    let Coin { value: _ } = coin2;
}
</code></pre>
<ul>
<li><code>Coin&lt;USD&gt;</code> 和 <code>Coin&lt;EUR&gt;</code> 使用 <code>&lt;T&gt;</code> 区分不同货币，防止混淆。</li>
</ul>
</li>
<li>
<p><strong>能力约束</strong>：类型参数可通过能力约束（如 <code>T: drop</code>）限制行为。例如：</p>
<pre><code>public struct Droppable&lt;T: drop&gt; {
  value: T,
}
public struct CopyableDroppable&lt;T: copy + drop&gt; {
  value: T,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 必须具有指定能力，否则编译器报错。例如，<code>NoAbilities</code> 结构体无能力，无法用于 <code>Droppable&lt;NoAbilities&gt;</code>.</li>
</ul>
</li>
</ul>
<h3 id="13-泛型的应用场景-1"><a class="header" href="#13-泛型的应用场景-1">1.3 泛型的应用场景</a></h3>
<p>在 Sui Move 智能合约中，泛型广泛应用于：</p>
<ul>
<li><strong>资源标识</strong>：如 <code>VoteToken&lt;T&gt;</code>，通过 <code>&lt;T&gt;</code> 区分不同类型的凭证（如治理代币、投票权）。</li>
<li><strong>模块复用</strong>：编写通用逻辑，适配多种类型。例如，<code>vote&lt;T&gt;</code> 函数处理不同类型的 <code>VoteToken</code>。</li>
<li><strong>跨模块交互</strong>：泛型支持模块与外部类型交互，增加灵活性。</li>
<li><strong>标准库</strong>：如 <code>vector&lt;T&gt;</code>（动态数组）和 <code>Option&lt;T&gt;</code>（可选值），分别存储任意类型序列和表示可能缺失的值。</li>
<li><strong>抽象实现</strong>：定义通用接口或行为，允许不同类型共享逻辑。</li>
</ul>
<p>在样例合约中，泛型用于：</p>
<ul>
<li><code>VoteToken&lt;phantom T&gt;</code>：标记投票凭证的合法性。</li>
<li><code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code>：支持不同类型凭证的分配和使用。</li>
</ul>
<p>然而，这种灵活性可能被攻击者利用，导致安全漏洞。</p>
<hr />
<h2 id="2-未检查泛型类型的安全风险-1"><a class="header" href="#2-未检查泛型类型的安全风险-1">2. 未检查泛型类型的安全风险</a></h2>
<h3 id="21-泛型漏洞的本质-1"><a class="header" href="#21-泛型漏洞的本质-1">2.1 泛型漏洞的本质</a></h3>
<p>在 Sui Move 中，泛型类型是由调用者在运行时提供的“用户输入”。如果合约未验证泛型类型 <code>&lt;T&gt;</code> 是否符合预期，攻击者可以传入任意类型，导致以下安全问题：</p>
<ul>
<li><strong>伪造凭证</strong>：攻击者创建非法类型的对象（如 <code>VoteToken&lt;FakeToken&gt;</code>）绕过权限检查。</li>
<li><strong>逻辑破坏</strong>：非预期类型导致合约状态异常，影响核心功能（如投票结果错误）。</li>
<li><strong>资源滥用</strong>：攻击者利用伪造类型创建无效资源，干扰合约运行或耗尽 Gas.</li>
</ul>
<p>在 <code>VoteChain</code> 合约中，<code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code> 函数未检查 <code>&lt;T&gt;</code> 类型，存在严重漏洞：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}

public entry fun vote&lt;T&gt;(store: &amp;mut VoteStore, token: &amp;VoteToken&lt;T&gt;, proposal_id: u64) {
    assert!(token.amount &gt; 0, 1);
    assert!(object_table::contains(&amp;store.proposals, proposal_id), 2);
    let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_id);
    proposal.votes = proposal.votes + token.amount;
}
</code></pre>
<ul>
<li><strong>漏洞</strong>：<code>register_voter&lt;T&gt;</code> 允许任何 <code>&lt;T&gt;</code> 创建 <code>VoteToken</code>，<code>vote&lt;T&gt;</code> 未验证 <code>token</code> 的类型。</li>
<li><strong>后果</strong>：攻击者可以伪造 <code>VoteToken</code> 并投票，非法影响提案结果.</li>
</ul>
<h3 id="22-漏洞案例分析-1"><a class="header" href="#22-漏洞案例分析-1">2.2 漏洞案例分析</a></h3>
<p>假设 <code>VoteChain</code> 是一个去中心化投票系统，设计意图是只有持有 <code>OfficialToken</code> 类型凭证的用户才能投票。然而，由于泛 type漏洞，攻击者可以：</p>
<ol>
<li>定义一个伪造类型 <code>FakeToken</code>:</li>
</ol>
<pre><code>module attacker::fake_token {
 public struct FakeToken has drop {}
}
</code></pre>
<ol start="2">
<li>调用 <code>register_voter&lt;attacker::fake_token::FakeToken&gt;</code> 获取 <code>VoteToken&lt;FakeToken&gt;</code>.</li>
<li>使用伪造的 <code>VoteToken&lt;FakeToken&gt;</code> 调用 <code>vote</code>，增加任意提案的票数。</li>
</ol>
<p>这种攻击在区块链 CTF 中非常常见，因为泛型类型作为“隐形输入”，容易被开发者忽视。在现实世界的治理合约或 DeFi 协议中，类似漏洞可能导致：</p>
<ul>
<li>非法用户控制投票结果。</li>
<li>资金分配错误。</li>
<li>协议治理被恶意操纵。</li>
</ul>
<h3 id="23-漏洞的影响-1"><a class="header" href="#23-漏洞的影响-1">2.3 漏洞的影响</a></h3>
<p>未检查泛型类型的漏洞可能导致：</p>
<ul>
<li><strong>完整性破坏</strong>：投票系统等依赖权限控制的合约可能被非法操作。</li>
<li><strong>经济损失</strong>：在 DeFi 或 DAO 中，伪造凭证可能导致资金被窃取或错误分配。</li>
<li><strong>拒绝服务</strong>：攻击者可能创建大量伪造对象，增加 Gas 消耗或干扰正常功能。</li>
</ul>
<p>在 <code>VoteChain</code> 的场景中，攻击者通过伪造 <code>VoteToken</code> 可以：</p>
<ul>
<li>使无效用户参与投票，破坏提案的公平性。</li>
<li>操纵提案结果，影响治理决策。</li>
<li>降低系统的可信度，损害用户信任。</li>
</ul>
<hr />
<h2 id="3-防御泛型漏洞-1"><a class="header" href="#3-防御泛型漏洞-1">3. 防御泛型漏洞</a></h2>
<h3 id="31-使用-stdtype_name-进行类型检查-1"><a class="header" href="#31-使用-stdtype_name-进行类型检查-1">3.1 使用 <code>std::type_name</code> 进行类型检查</a></h3>
<p>Sui Move 提供了 <code>std::type_name</code> 模块，用于在运行时检查类型的名称。开发者可以在合约中添加断言，确保泛型类型 <code>&lt;T&gt;</code> 符合预期：</p>
<pre><code>use std::type_name;

public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    assert!(type_name::get&lt;T&gt;() == type_name::get&lt;votechain::OfficialToken&gt;(), 3);
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>type_name::get&lt;T&gt;()</code> 返回 <code>&lt;T&gt;</code> 的完整类型名称（包括模块和结构体名称，如 <code>votechain::OfficialToken</code>）。</li>
<li>断言确保 <code>&lt;T&gt;</code> 是 <code>votechain::OfficialToken</code>，否则中止交易。</li>
<li>错误码 <code>3</code>（建议定义为常量，如 <code>const E_INVALID_TYPE: u64 = 3;</code>）便于调试。</li>
</ul>
<p>这种方法通过限制 <code>&lt;T&gt;</code> 到白名单类型，有效防止伪造凭证。</p>
<h3 id="32-设计安全合约的注意事项-1"><a class="header" href="#32-设计安全合约的注意事项-1">3.2 设计安全合约的注意事项</a></h3>
<ul>
<li><strong>最小化泛型使用</strong>：仅在必要时使用泛型，避免过度灵活性。</li>
<li><strong>显式验证</strong>：对所有泛型参数进行运行时检查。</li>
<li><strong>错误处理</strong>：定义清晰的错误码，便于调试和审计。</li>
<li><strong>测试覆盖</strong>：编写测试用例，模拟攻击者伪造类型的情景。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践利用泛型漏洞伪造投票凭证"><a class="header" href="#实践利用泛型漏洞伪造投票凭证">实践：利用泛型漏洞伪造投票凭证。</a></h1>
<h2 id="引言-2"><a class="header" href="#引言-2">引言</a></h2>
<p>以下是一个简单的投票系统的合约，每个地址可以领取100数量的coin然后进行投票，但是存在一些漏洞问题请尝试找出问题。</p>
<pre><code>module votechain::vote {
    use sui::object_table::{Self, ObjectTable};
    use sui::coin::{Self,TreasuryCap};
    use sui::transfer::{public_transfer, share_object, public_freeze_object};
    use std::string::String;
    use sui::table::{Self, Table};

    public struct VOTE has drop {}

    public struct Votecap has key {
        id: UID,
        cap: TreasuryCap&lt;VOTE&gt;
    }

    public struct Mintlist has key {
        id: UID,
        mintlist: Table&lt;address, u64&gt;
    }

    public struct VoteToken&lt;phantom T&gt; has key, store {
        id: UID,
        amount: u64,
    }

    public struct VoteStore has key {
        id: UID,
        proposals: ObjectTable&lt;String, Proposal&gt;,
    }

    public struct Proposal has key, store {
        id: UID,
        votes: u64,
    }


    fun init(waitness: VOTE,ctx: &amp;mut TxContext) {
        let name = std::string::utf8(b"letsctf");

        let mintlist = Mintlist { id: object::new(ctx) , mintlist: table::new(ctx) };
        let mut store = VoteStore {
            id: object::new(ctx),
            proposals: object_table::new(ctx),
        };

        let proposal = Proposal {
            id: object::new(ctx),
            votes: 0,
        };

        let (treasury_cap, meta) = coin::create_currency(waitness,6,b"VOTE", b"VOTE", b"", option::none(), ctx);
  
        let vote_cap = Votecap { id: object::new(ctx), cap: treasury_cap };

        object_table::add(&amp;mut store.proposals, name, proposal);
        public_freeze_object(meta);
        share_object(vote_cap);
        share_object(mintlist);
        share_object(store);
    }

    public entry fun mint(
        vote_cap: &amp;mut Votecap,
        mint_list: &amp;mut Mintlist,
        ctx: &amp;mut TxContext
    ){
        let addr = ctx.sender();
        assert!(!table::contains(&amp;mint_list.mintlist, addr), 1);
        let coin = coin::mint(&amp;mut vote_cap.cap, 100, ctx);
        table::add(&amp;mut mint_list.mintlist, addr, 100);
        public_transfer(coin, addr);
    }

    public entry fun register_voter&lt;T&gt;(vote_coin: coin::Coin&lt;T&gt;, ctx: &amp;mut TxContext) {
        let amount = vote_coin.value();
        assert!(amount == 100,1);
        let sender = tx_context::sender(ctx);
        let token = VoteToken&lt;T&gt; {
            id: object::new(ctx),
            amount: 100,
        };
        public_transfer(token, sender);
        public_transfer(vote_coin, @0x0);
    }

    public entry fun vote&lt;T&gt;(token: &amp;VoteToken&lt;T&gt;, store: &amp;mut VoteStore, proposal_name: String) {
        assert!(token.amount &gt; 0, 1);
        assert!(object_table::contains(&amp;store.proposals, proposal_name), 2);

        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        proposal.votes = proposal.votes + token.amount;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4章资源管理"><a class="header" href="#第4章资源管理">第4章：资源管理</a></h1>
<h2 id="引言-3"><a class="header" href="#引言-3">引言</a></h2>
<p>在区块链智能合约中，资源管理是确保系统安全的关键。Sui Move 使用对象（如代币、共享状态）来管理资源，通过 has key、Coin 和 share_object 提供强大的控制能力。然而，错误的资源管理可能导致漏洞，如代币重复使用。本章将介绍 Sui Move 的资源管理，以 VoteChain 投票系统为例，探讨未正确销毁投票代币的漏洞，学习如何利用和修复此类问题。</p>
<p>通过本章，你将：</p>
<ul>
<li>了解 Sui Move 的对象和代币管理。</li>
<li>掌握资源管理漏洞，如未销毁代币导致重复投票。</li>
<li>学会在 CTF 中发现和修复资源管理问题。</li>
</ul>
<p>我们将分析 chapter_4::vote 中的重复投票漏洞，实践操纵投票结果，并在任务中修复代币管理。</p>
<hr />
<h2 id="1-sui-move-的资源管理"><a class="header" href="#1-sui-move-的资源管理">1. Sui Move 的资源管理</a></h2>
<h3 id="11-对象与代币"><a class="header" href="#11-对象与代币">1.1 对象与代币</a></h3>
<p>Sui Move 的资源以对象形式存储，具备唯一标识（UID）：</p>
<ul>
<li>对象类型：需 has key（唯一性）和 has store（可存储）。</li>
<li>所有权：通过 public_transfer 转移，share_object 公开共享。</li>
<li>代币：Coin<T> 表示代币，需销毁（coin::burn）或分割（coin::split）以防止重复使用。</li>
</ul>
<p>在 VoteChain 中：</p>
<ul>
<li>Coin<VOTE> 是投票代币，代表投票权。</li>
<li>VoteStore 是共享对象，存储提案票数。</li>
</ul>
<h3 id="12-资源管理漏洞"><a class="header" href="#12-资源管理漏洞">1.2 资源管理漏洞</a></h3>
<p>常见的资源管理漏洞包括：</p>
<ul>
<li>未销毁代币：投票后未销毁 Coin<VOTE>，允许重复使用。</li>
<li>错误转移：对象转移到错误地址，丢失控制。</li>
<li>共享对象滥用：未限制 share_object 的访问（第5章讨论）。</li>
</ul>
<p>这些漏洞可能导致投票操纵或资源滥用。</p>
<h3 id="13-漏洞案例"><a class="header" href="#13-漏洞案例">1.3 漏洞案例</a></h3>
<p>在 VoteChain 的 chapter_4::vote 中：</p>
<ul>
<li>vote 函数记录投票者，但未销毁或分割 Coin<VOTE>。</li>
<li>攻击者可多次调用 vote，用同一代币增加票数，操纵提案结果。</li>
<li>危害：投票系统公平性丧失。</li>
</ul>
<hr />
<h2 id="2-防御资源管理漏洞"><a class="header" href="#2-防御资源管理漏洞">2. 防御资源管理漏洞</a></h2>
<h3 id="21-销毁或分割代币"><a class="header" href="#21-销毁或分割代币">2.1 销毁或分割代币</a></h3>
<ul>
<li>在 vote 中销毁 Coin<VOTE>（coin::burn）或分割已用部分（coin::split）。</li>
<li>示例：coin::burn(vote_coin);</li>
</ul>
<h3 id="22-验证状态"><a class="header" href="#22-验证状态">2.2 验证状态</a></h3>
<ul>
<li>检查代币是否有效（如 vote_coin.value() &gt; 0）。</li>
<li>记录投票状态（如 voters 列表），防止重复投票。</li>
</ul>
<h3 id="23-最小化共享对象"><a class="header" href="#23-最小化共享对象">2.3 最小化共享对象</a></h3>
<ul>
<li>减少 share_object 的敏感数据，仅存储必要信息（如票数）。</li>
<li>使用用户拥有的对象（如代币）管理权限。</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="了解资源管理问题"><a class="header" href="#了解资源管理问题">了解资源管理问题</a></h1>
<h2 id="引言-4"><a class="header" href="#引言-4">引言</a></h2>
<p>在区块链智能合约中，资源管理是确保系统安全的关键。Sui Move 使用对象（如代币、共享状态）来管理资源，通过 has key、Coin 和 share_object 提供强大的控制能力。然而，错误的资源管理可能导致漏洞，如代币重复使用。本章将介绍 Sui Move 的资源管理，以 VoteChain 投票系统为例，探讨未正确销毁投票代币的漏洞，学习如何利用和修复此类问题。</p>
<p>通过本章，你将：</p>
<ul>
<li>了解 Sui Move 的对象和代币管理。</li>
<li>掌握资源管理漏洞，如未销毁代币导致重复投票。</li>
<li>学会在 CTF 中发现和修复资源管理问题。</li>
</ul>
<p>我们将分析 chapter_4::vote 中的重复投票漏洞，实践操纵投票结果，并在任务中修复代币管理。</p>
<hr />
<h2 id="1-sui-move-的资源管理-1"><a class="header" href="#1-sui-move-的资源管理-1">1. Sui Move 的资源管理</a></h2>
<h3 id="11-对象与代币-1"><a class="header" href="#11-对象与代币-1">1.1 对象与代币</a></h3>
<p>Sui Move 的资源以对象形式存储，具备唯一标识（UID）：</p>
<ul>
<li>对象类型：需 has key（唯一性）和 has store（可存储）。</li>
<li>所有权：通过 public_transfer 转移，share_object 公开共享。</li>
<li>代币：Coin<T> 表示代币，需销毁（coin::burn）或分割（coin::split）以防止重复使用。</li>
</ul>
<p>在 VoteChain 中：</p>
<ul>
<li>Coin<VOTE> 是投票代币，代表投票权。</li>
<li>VoteStore 是共享对象，存储提案票数。</li>
</ul>
<h3 id="12-资源管理漏洞-1"><a class="header" href="#12-资源管理漏洞-1">1.2 资源管理漏洞</a></h3>
<p>常见的资源管理漏洞包括：</p>
<ul>
<li>未销毁代币：投票后未销毁 Coin<VOTE>，允许重复使用。</li>
<li>错误转移：对象转移到错误地址，丢失控制。</li>
<li>共享对象滥用：未限制 share_object 的访问（第5章讨论）。</li>
</ul>
<p>这些漏洞可能导致投票操纵或资源滥用。</p>
<h3 id="13-漏洞案例-1"><a class="header" href="#13-漏洞案例-1">1.3 漏洞案例</a></h3>
<p>在 VoteChain 的 chapter_4::vote 中：</p>
<ul>
<li>vote 函数记录投票者，但未销毁或分割 Coin<VOTE>。</li>
<li>攻击者可多次调用 vote，用同一代币增加票数，操纵提案结果。</li>
<li>危害：投票系统公平性丧失。</li>
</ul>
<hr />
<h2 id="2-防御资源管理漏洞-1"><a class="header" href="#2-防御资源管理漏洞-1">2. 防御资源管理漏洞</a></h2>
<h3 id="21-销毁或分割代币-1"><a class="header" href="#21-销毁或分割代币-1">2.1 销毁或分割代币</a></h3>
<ul>
<li>在 vote 中销毁 Coin<VOTE>（coin::burn）或分割已用部分（coin::split）。</li>
<li>示例：coin::burn(vote_coin);</li>
</ul>
<h3 id="22-验证状态-1"><a class="header" href="#22-验证状态-1">2.2 验证状态</a></h3>
<ul>
<li>检查代币是否有效（如 vote_coin.value() &gt; 0）。</li>
<li>记录投票状态（如 voters 列表），防止重复投票。</li>
</ul>
<h3 id="23-最小化共享对象-1"><a class="header" href="#23-最小化共享对象-1">2.3 最小化共享对象</a></h3>
<ul>
<li>减少 share_object 的敏感数据，仅存储必要信息（如票数）。</li>
<li>使用用户拥有的对象（如代币）管理权限。</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践分析利用资源管理漏洞"><a class="header" href="#实践分析利用资源管理漏洞">实践：分析利用资源管理漏洞</a></h1>
<pre><code>module chapter_4::vote {
    use sui::coin::{Self, Coin, TreasuryCap};
    use sui::transfer::{public_transfer, share_object, public_freeze_object};
    use sui::vec_map::{Self, VecMap};
    use sui::object_table::{Self, ObjectTable};
    use std::string::String;

    public struct VOTE has drop {}

    public struct Votecap has key {
        id: UID,
        cap: TreasuryCap&lt;VOTE&gt;,
    }

    public struct Mintlist has key {
        id: UID,
        mintlist: VecMap&lt;address, u64&gt;,
    }

    public struct VoteStore has key {
        id: UID,
        proposals: ObjectTable&lt;String, Proposal&gt;,
        voters: VecMap&lt;address, bool&gt;, 
    }

    public struct Proposal has key, store {
        id: UID,
        votes: u64,
    }

    const E_INVALID_AMOUNT: u64 = 1;
    const E_INVALID_PROPOSAL: u64 = 2;
    const E_ALREADY_MINTED: u64 = 3;

    fun init(witness: VOTE, ctx: &amp;mut TxContext) {
        let name = std::string::utf8(b"letsctf");
        let (treasury_cap, meta) = coin::create_currency(
            witness,
            6,
            b"VOTE",
            b"VOTE",
            b"",
            option::none(),
            ctx
        );

        let vote_cap = Votecap { id: object::new(ctx), cap: treasury_cap };
        let mintlist = Mintlist { id: object::new(ctx), mintlist: vec_map::empty() };
        let mut store = VoteStore {
            id: object::new(ctx),
            proposals: object_table::new(ctx),
            voters: vec_map::empty(),
        };

        let proposal = Proposal {
            id: object::new(ctx),
            votes: 0,
        };

        object_table::add(&amp;mut store.proposals, name, proposal);
        public_freeze_object(meta);
        share_object(vote_cap);
        share_object(mintlist);
        share_object(store);
    }

    public entry fun mint(
        vote_cap: &amp;mut Votecap,
        mint_list: &amp;mut Mintlist,
        ctx: &amp;mut TxContext
    ) {
        let addr = tx_context::sender(ctx);
        assert!(!vec_map::contains(&amp;mint_list.mintlist, &amp;addr), E_ALREADY_MINTED);
        let coin = coin::mint(&amp;mut vote_cap.cap, 100, ctx);
        vec_map::insert(&amp;mut mint_list.mintlist, addr, 100);
        public_transfer(coin, addr);
    }

    public entry fun vote(
        store: &amp;mut VoteStore,
        vote_coin: &amp;Coin&lt;VOTE&gt;,
        proposal_name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(vote_coin.value() &gt; 0, E_INVALID_AMOUNT);
        assert!(object_table::contains(&amp;store.proposals, proposal_name), E_INVALID_PROPOSAL);
        let sender = tx_context::sender(ctx);
        if (!vec_map::contains(&amp;store.voters, &amp;sender)) {
            vec_map::insert(&amp;mut store.voters, sender, true);
        };
        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        proposal.votes = proposal.votes + vote_coin.value();
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
